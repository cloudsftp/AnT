/* 
 * Copyright (C) 1999-2004 the AnT project,
 * Department of Image Understanding,
 * University of Stuttgart, Germany.
 * 
 * This file is part of AnT,
 * a simulation and analysis tool for dynamical systems.
 * 
 * AnT is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AnT is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
 *
 * $Id: MultivariatePolynomGenerator.hpp,v 1.3 2004/12/09 14:41:13 rtlammer Exp $
 *
 */

#ifndef MULTIVARIATE_POLYNOM_GENERATOR_HPP
#define MULTIVARIATE_POLYNOM_GENERATOR_HPP

#include "AnT.hpp"
#include "methods/output/IOStreamFactory.hpp"
#include <vector>
using std::vector;

ostream* mvpFileName = NULL;


class MVP_HeaderWriter
    : public ScanTransition
{
private:
    const int order;    
    
public:
    MVP_HeaderWriter ( int anOrder,
		       const string& fileName = MVP_FILE_NAME)
	: ScanTransition ("Multivariate polynom generator method"),
	  order (anOrder)
	{
	    assert (mvpFileName == NULL);
	    mvpFileName = ioStreamFactory->getOStream (fileName);
	}


public:
    virtual void execute (ScanData& scanData)
	{
	    assert (mvpFileName != NULL);

	    const Array<real_t>& initialState0
		= scanData.iterData().dynSysData.initialStates[0];
	    int stateSpaceDim = initialState0.getTotalSize ();

	    const string GENERATED_BY_STRING
		= string ("This file is generated by AnT ")
		+ ANT_MAJOR + '.' + ANT_MINOR
#if 1 // 0 /* commented out */
		+ ", Release " + ANT_SUB + ANT_REV
#endif
		+ ", (c) " + ANT_YEARS;

	    (*mvpFileName) << OUTPUT_COMMENT_CHAR 
			   << " "
			   << GENERATED_BY_STRING
			   << ","
			   << endl
			   << OUTPUT_COMMENT_CHAR 
			   << " at ";
  
	    printTimeOfDay (mvpFileName);

	    (*mvpFileName)
		<< endl;

	    (scanData.iterData().dynSysData)
		.printDescription ((*mvpFileName));

	    (*mvpFileName) << OUTPUT_COMMENT_CHAR
			   << endl;

	    int scanMode = scanData.getScanMode ();

	    (*mvpFileName) << OUTPUT_COMMENT_CHAR
			   << " "
			   << "Scan mode:"
			   << " "
			   << scanMode;

	    if (scanMode <= 0)
	    {
		(*mvpFileName) << " "
			       << "(a single simulation run)";
	    }

	    (*mvpFileName)
		<< endl
		<< OUTPUT_COMMENT_CHAR
		<< " Max order of monomials: "
		<< order
		<< endl
		<< OUTPUT_COMMENT_CHAR
		<< " Number of monomials: "
		<< binomial( stateSpaceDim + order, order )
		<< endl
		<< endl;
	}
};


class MultivariatePolynomGenerator
    : public IterTransition
{
private:
    const int order;
    ostream* const f;


public:
    MultivariatePolynomGenerator ( int anOrder)
	: IterTransition ("Multivariate polynom generator method"),
	  order (anOrder),
          f (mvpFileName)
	{}

    void proceedWithMonomial (const vector<real_t>& monomial)
	{
	    for ( vector<real_t>::const_iterator m = monomial.begin ();
		  m != monomial.end ();
		  ++m ) {
		(*mvpFileName) << *m << " ";
	    }
	}


public:
    virtual void execute (IterData& iterData)
	{
	    assert (mvpFileName != NULL);

	    const Array<real_t>& currentState
		= iterData.dynSysData.orbit[0];
	    int stateSpaceDim = currentState.getTotalSize ();

	    vector<int> oldLengths (stateSpaceDim);
	    vector<int> lengths (stateSpaceDim);

	    for (int i = 0; i < stateSpaceDim; ++i) {
		oldLengths[i] = 0;
	    }

	    vector<real_t> monomial;
	    assert (monomial.empty ());
	    monomial.push_back (1);

	    for (int k = 0; k <= order; ++k) {
		proceedWithMonomial (monomial);

		vector<real_t> oldMonomial;
		assert (oldMonomial.empty ());
		std::swap (monomial, oldMonomial);
		assert (monomial.empty ());

		lengths[0] = oldMonomial.size ();
		int i = 0;
		while (true) {
		    for ( int j = oldMonomial.size () - lengths[i];
			  j < oldMonomial.size ();
			  ++j ) {
			monomial.push_back (currentState[i] * oldMonomial[j]);
		    }

		    ++i;
		    if (i >= stateSpaceDim) {
			break;
		    }

		    lengths[i] = lengths[i - 1] - oldLengths[i - 1];
		}

		std::swap (lengths, oldLengths);
	    }

	    (*mvpFileName) << endl;
	}
};

#endif
