# 
# Copyright (C) 1999-2007 the AnT project,
# Department of Image Understanding,
# University of Stuttgart, Germany.
# 
# This file is part of AnT,
# a simulation and analysis tool for dynamical systems.
# 
# AnT is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# AnT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
#
# $Id: GlobalKeys.cfg,v 1.100 2010/11/11 14:53:16 schanzml Exp $
#


# This file is read after parsing (syntactic analyzing) the ini-file;
# The purpose is to allow a plausibility check and semantic analysis
# of the parse tree built so far


# entry = {
#  @key =
#  @type =
# }

#@global = {
# @string = "*",
# @boolean = (yes, no)
#},

dynamical_system = {
 @label = "dynamical system",

 @tooltip = 
"This section is for specifying the dynamical system (type, parameters, initial states, ...)",

 @key = DYNAMICAL_SYSTEM_KEY,
 @type = @record,
 @record = {
  type = {
   @key = SYSTEM_TYPE_KEY,
   @label = "dynamical system type",
   @tooltip = "Type of the dynamical system, like map, ODE, DDE, etc.",
   @type = @enum,
   @enum = {map              = MAP_KEY,
            ode              = ODE_KEY,
            dde              = DDE_KEY,
            fde              = FDE_KEY,
            pde_1d           = PDE_1D_KEY,
            codel            = CODEL_KEY,
            recurrent_map    = RECURRENT_MAP_KEY,
            cml              = CML_KEY,
            external_data    = EXTERNAL_DATA_KEY,
            hybrid_map       = HYBRID_MAP_KEY,
            hybrid_ode       = HYBRID_ODE_KEY,
            hybrid_dde       = HYBRID_DDE_KEY,
            stochastical_map = STOCHASTICAL_MAP_KEY,
            averaged_map     = AVERAGED_MAP_KEY,
            stochastical_ode = STOCHASTICAL_ODE_KEY,
            stochastical_dde = STOCHASTICAL_DDE_KEY,
            poincare_map     = POINCARE_MAP_KEY
           }
  },

  name = {
   @key = SYSTEM_NAME_KEY,
   @type = @string,
   @default = "none",
   @label = "dynamical system name",
   @tooltip = "This field is needed for documentation reasons only."
  },

# --- General -----------------------------------
  parameter_space_dimension = {
   @key = PARAMETER_SPACE_DIM_KEY,
   @type = @integer,
   @readonly = yes,
   @default = 0,
   @min = 0,
   @label = "number of parameters",
   @tooltip = "Number of system parameters."

  },

  parameters = {
   @key = PARAMETERS_KEY,
   @type = @record,
   @label = "system parameters",
   @tooltip = "Description of system parameters.",
   @record = {
    parameter[] = {
     @key = PARAMETER,
     @type = @record,
     @dynamic = yes,
     @record = {
      value = {@key = VALUE_KEY, @type = @real},
      name  = {@key = NAME_KEY,  @type = @string}
     },
     @label = "specific parameters",
     @tooltip = "System parameters will be described individual and may possess names. Then, the names can be used for scan reasons."
    }, # parameter[]

    array =
    { @key = ARRAY_KEY,
      @type = @array,
      @depth = 1,
      @element = {@type = @real},
      @dynamic = yes,
      @label = "parameters array",
      @tooltip = "System parameters will be described within an array."
    }
   } # array
  }, #parameters

  state_space_dimension = {
   @key = STATE_SPACE_DIM_KEY,
   @type = @integer,
   @label = "state space dimension",
   @tooltip = "Number of state variables. Note, that if you deal with a spatial inhomogeneous dynamical system, like CML or PDE, then this field means the number of state variables at each spatial point. If you deal with a hybrid dynamical system, then this field means the number of the real-valued state variables. Be careful with this field. The number of state space must be identical with the one used by the implementation of your dynamical system. Otherwise the simulation will be aborted.",
   @min = 1,
   @default = 1
  },

  s[] = {
     @key = SYSTEM_FUNCTIONS_KEY,
     @type = @record,
     @dynamic = no,
     @optional = yes,
     @record = {
        name  = {
          @key = NAME_KEY,  
          @type = @string
        },
        equation_of_motion = {
          @key = EQUATION_OF_MOTION_KEY,  
          @type = @string,
          @label = "equation of motion",
          @default = "0"
        }
     },
     @label = "system functions",
     @tooltip = "The equations of motion for the system to be investigated..."
    },

# --- Recurrent maps ----------------------------
  recurrence_level = {
   @key = RECURRENCE_LEVEL_KEY,
   @type = @integer,
   @label = "recurrence level",
   @tooltip = "Number of states needed for calculation of the next state. The curent state is counted as well.",
   @min = 1,
   @default = 2
  },

# --- CMLs and CODELs ---------------------------
  number_of_cells =
  { @key = NUMBER_OF_CELLS_KEY,
    @type = @integer,
    @label = "number of cells",
    @tooltip = "Number of cells.",
    @default = 10,
    @min = 1
  },

# --- Initial states ----------------------------
  initial_state =
  { @key = INITIAL_STATE_KEY,
    @type = @array,
    @depth = 1, # or 2 ?!
    @element = {@type = @real},
    @label = "initial state",
    @tooltip = "Initial states for all state variables. If you deal with a hybrid dynamical system, then this field means the initial states for the real-valued state variables."
  },

  continuous_initial_state =
  { @key = CONT_INITIAL_STATE_KEY,
    @type = @array,
    @depth = 1, # or 2 ?!
    @element = {@type = @real},
    @label = "continuous initial state",
    @tooltip = "Initial states for real-valued state variables."
  },

  discrete_state_space_dimension = {
   @key = DISCRETE_STATE_SPACE_DIM_KEY,
   @type = @integer,
   @min = 1,
   @default = 1,
   @label = "discrete state space dimension",
   @tooltip = "Number of integer-valued state variables."
  },

  discrete_initial_state =
  { @key = DISCRETE_INITIAL_STATE_KEY,
    @type = @array,
    @depth = 1, # or 2 ?!
    @element = {@type = @integer},
    @dynamic = no,
    @label = "discrete initial state",
    @tooltip = "Initial states for integer-valued state variables."
  },

  temporal_initial_function[] =
  { @key = TEMPORAL_INITIAL_FUNCTION,
    @type = @record,
    @label = "initial functions",
    @tooltip = "Initial functions for specific state variables. If you deal with a dynamical system with memory, like DDE or FDE, the function is defined on the interval [-tau, 0], whereby tau is the (maximal) delay time. If you deal with a spatial inhomogeneous dynamical system, like CML or PDE, the function is defined on the spatial domain.",
    @record =
    { type =
      { @key = FUNCTION_NAME_KEY,
        @type = @enum,
        @enum =
        { constant        = CONST_FUNCTION_NAME_KEY,
          random          = RANDOM_FUNCTION_NAME_KEY,
          step            = STEP_FUNCTION_NAME_KEY,
          periodic_step   = PERIODIC_STEP_FUNCTION_NAME_KEY,
          singular        = SINGULAR_FUNCTION_NAME_KEY,
          sawtooth        = SAWTOOTH_FUNCTION_NAME_KEY,
          polynomial      = POLYNOMIAL_FUNCTION_NAME_KEY,
          sin             = SIN_FUNCTION_NAME_KEY,
          sinc            = SINC_FUNCTION_NAME_KEY,
          gauss           = GAUSS_FUNCTION_NAME_KEY,
          fermi           = FERMI_FUNCTION_NAME_KEY
        },
        @default = constant
      },

      amplitude =
      { @key = AMPLITUDE_KEY,
        @type = @real,
        @default = 1.0
      },

      offset =
      { @key = OFFSET_KEY,
        @type = @real,
        @default = 0.0
      },

      period =
      { @key = PERIOD_KEY,
        @type = @real
      },

      sigma =
      { @key = SIGMA_KEY,
        @type = @real,
        @default = 1.0
      },

      width =
      { @key = WIDTH_KEY,
        @type = @real
      },

      degree =
      { @key = DEGREE_KEY,
        @type = @integer,
        @readonly = yes,
        @default = 0,
        @min = 0
      },

      coefficients =
      { @key = COEFFICIENTS_KEY,
        @type = @array,
        @depth = 1,
        @element = {@type = @real, @default = 1.0},
        @dynamic = yes
      },

      relative_peak_position =
      { @key = RELATIVE_PEAK_POSITION_KEY,
        @type = @real
      },

      argument_shift =
      { @key = ARGUMENT_SHIFT_KEY,
        @type = @real,
        @default = 0.0,
        @tooltip = "The shift of the argument, sometimes denoted simply as shift or phase."
      },

      random_specification =
      { @key = RANDOM_SPECIFICATION_KEY,
        @type = @like,
        @like = (dynamical_system,noisy_variable[])
      }
    }
  }, # temporal_initial_function[]

  spatial_initial_function[] =
  { @key = SPATIAL_INITIAL_FUNCTION,
    @type = @like,
    @like = (dynamical_system,temporal_initial_function[])
  },

  reset_initial_states_from_orbit =
  { @key = RESET_INITIAL_STATES_FROM_ORBIT_KEY,
    @type = @boolean,
    @default = false,
    @label = "reset initial states from orbit",
    @tooltip = "The setting of this field is relevant if you perform a scan run. If it is off, the same initial values will be used for each specific simulation run. Otherwise, the initial values for the next simulation run will be resetted for the previous one from the last states of the trajectory. Be careful by running the simulator in the distributed mode (see AnT Reference Manual for more details)."
  },

# --- DDEs --------------------------------------
  delay = {
   @key = DELAY_KEY,
   @type = @real,
   @tooltip = "Delay time."
  },

# --- FDEs --------------------------------------
  maximal_delay = {
   @key = MAX_DELAY_KEY,
   @type = @real,
   @tooltip = "Maximal delay time."
  },

# --- PDEs --------------------------------------
  domain_boundary = {
   @key = DOMAIN_BOUNDARY_KEY,
   @type = @array,
   @depth = 2,
   @element = {@type = @real},
   @label = "domain boundary",
   @tooltip = "Domain boundary for each state variable."
  },

  number_of_grid_points = {
   @key = NUMBER_OF_GRID_POINTS_KEY,
   @type = @integer,
   @default = 50,
   @min = 1,
   @label = "number of grid points",
   @tooltip = "number of grid points on the spatial domain."
  },

  neumann_boundary_conditions = {
   @key = BOUNDARY_CONDITIONS_KEY,
   @label = "neumann boundary conditions",
   @tooltip = "Neumann boundary conditions.",
   @type = @record,
   @record = {
    default_policy =
    {
     @key = DEFAULT_POLICY_KEY,
     @type = @enum,
     @enum = { fluxless = FLUXLESS_KEY,
               cyclic = CYCLIC_KEY,
               interpolated = INTERPOLATED_KEY
             },
     @default = fluxless
    },
    number_of_differential_operators =
    {
     @key = NUMBER_OF_DIFFERENTIAL_OPERATORS_KEY,
     @type = @integer,
     @readonly = yes,
     @default = 0,
     @min = 0
    },

    operator[] =
    {
     @key = OPERATOR,
     @type = @record,
     @dynamic = yes,
     @record =
     {
      name =
      { @key = NAME_KEY,
        @type = @string, # to do
        @default = "D<0>"
      },

      policy =
      { @key = POLICY_KEY,
         @type = @enum,
         @enum = { fluxless = FLUXLESS_KEY,
                   cyclic = CYCLIC_KEY,
                   interpolated = INTERPOLATED_KEY,
                   constant = CONSTANT_KEY
                 },
         @default = fluxless
      },

      lower_boundary_value =
      { @key = LOWER_BOUNDARY_VALUE_KEY,
        @type = @real
      },

      upper_boundary_value =
      { @key = UPPER_BOUNDARY_VALUE_KEY,
         @type = @real
      }
     }
    } # operator[]
   }
  }, # neumann_boundary_conditions

  dirichlet_boundary_conditions =
  { @key = DIRICHLET_BOUNDARY_CONDITIONS_KEY,
    @type = @boolean,
    @default = false,
    @label = "dirichlet boundary conditions",
    @tooltip = "Dirichlet boundary conditions."   
  },

# --- External data reader ----------------------

  external_data_filename =
  { @key = EXTERNAL_DATA_FILENAME_KEY,
    @type = @string,
    @label = "external data filename",
    @tooltip = "Name of the data file to be read, it means, the date source."
  },

  number_of_columns =
  { @key = NUMBER_OF_COLUMNS_KEY,
    @type = @integer,
    @default = 1,
    @min = 1,
    @label = "number of columns",
    @tooltip = "Number of columns in the data file."
  },

  action_on_wrong_lines =
  { @key = ACTION_ON_WRONG_LINES_KEY,
    @type = @enum,
    @enum = { ignore = IGNORE_ACTION_KEY,
              exit = EXIT_ACTION_KEY
            },
    @default = exit, 
    @label = "action on wrong lines",
    @tooltip = "What is to do, if in the data file a line will be found, which can not be proceeded correctly. This case occurs, for instance, if a line contains a wrong number of data entities (numbers)."
  },

  accept_empty_lines =
  { @key = ACCEPT_EMPTY_LINES_KEY,
    @type = @boolean,
    @default = false,
    @label = "accept empty lines",
    @tooltip = "What is to do, if in the data file an empty line will be found. If this field is activated, empty lines will be ignored."
  },

  data_input =
  { @key = DATA_INPUT_DESCRIPTION_KEY,
    @type = @record,
    @label = "data input description",
    @tooltip = "This part describes, how the content of the data file has to be interpreted.",
    @record =
    { variable[] =
      { @key = VARIABLE,
        @type = @record,	
        @label = "specific variables",
        @tooltip = "Mapping of the data file content to a dynamical system.",
        @dynamic = no,
        @record =
        { column =
          { @key = COLUMN_KEY,
            @type = @integer,
            @min = 0,
	    @tooltip = "column in the data file"
          },

          data_type =
          { @key = TYPE_KEY,
            @type = @enum,
            @enum = { real = REAL_KEY,
                      integer = INTEGER_KEY
                    },
            @default = real,
	    @label = "data type",
	    @tooltip = "type of the data in this column."
          } # data_type
        }
      } # variable[]
    }
  }, # data_input

# --- General -----------------------------------
  number_of_iterations =
  { @key = NUMBER_OF_ITERATIONS_KEY,
    @type = @integer,
    @default = 10000,
    @min = 1,
    @label = "number of iterations",
    @tooltip = "Number of iterations to be performed."
  },

  integration =
  { @key = INTEGRATION_METHOD_KEY,
    @type = @record,
    @record =
    { method =
      { @key = METHOD_KEY,
        @type = @enum,
        @enum =
        { euler_forward         = EULER_FORWARD_KEY,
          heun                  = HEUN_KEY,
          midpoint              = MIDPOINT_KEY,
          ralston               = RALSTON_KEY,
          radau                 = RADAU_KEY,
          rk44                  = RK44_KEY,
          gill44                = GILL44_KEY,
          rkm45                 = RKM45_KEY,
          rkf456                = RKF456_KEY,

          using_butcher_array   = BUTCHER_KEY,

          euler_backward        = EULER_BACKWARD_KEY,
          heun_backward         = HEUN_BACKWARD_KEY,

          bdf                   = BDF_KEY,
          adams_moulton         = ADAMS_MOULTON_KEY,
          adams_bashforth       = ADAMS_BASHFORTH_KEY,
          pece_ab_am            = PECE_AB_AM_KEY,
          pece_ab_bdf           = PECE_AB_BDF_KEY,

          euler_forward_manhattan   = EULER_FORWARD_MANHATTAN_KEY,
          heun_manhattan            = HEUN_MANHATTAN_KEY,
          midpoint_manhattan        = MIDPOINT_MANHATTAN_KEY,
          ralston_manhattan         = RALSTON_MANHATTAN_KEY,
          radau_manhattan           = RADAU_MANHATTAN_KEY,
          rk44_manhattan            = RK44_MANHATTAN_KEY,
          gill44_manhattan          = GILL44_MANHATTAN_KEY,
          rkm45_manhattan           = RKM45_MANHATTAN_KEY,
          rkf456_manhattan          = RKF456_MANHATTAN_KEY,
          using_butcher_array_with_manhattan = BUTCHER_MANHATTAN_KEY,
          adams_bashforth_manhattan = ADAMS_BASHFORTH_MANHATTAN_KEY,
          pece_ab_am_manhattan      = PECE_AB_AM_MANHATTAN_KEY,
          pece_ab_bdf_manhattan     = PECE_AB_BDF_MANHATTAN_KEY,

          euler_forward_halfstep    = EULER_FORWARD_HALFSTEP_KEY,
          heun_halfstep             = HEUN_HALFSTEP_KEY,
          midpoint_halfstep         = MIDPOINT_HALFSTEP_KEY,
          ralston_halfstep          = RALSTON_HALFSTEP_KEY,
          radau_halfstep            = RADAU_HALFSTEP_KEY,
          gill44_halfstep           = GILL44_HALFSTEP_KEY,
          rk44_halfstep             = RK44_HALFSTEP_KEY,
          rkm45_halfstep            = RKM45_HALFSTEP_KEY,
          rkf456_halfstep           = RKF456_HALFSTEP_KEY,
          using_butcher_array_with_halfstep  = BUTCHER_HALFSTEP_KEY,
          adams_bashforth_halfstep  = ADAMS_BASHFORTH_HALFSTEP_KEY,
          pece_ab_am_halfstep       = PECE_AB_AM_HALFSTEP_KEY,
          pece_ab_bdf_halfstep      = PECE_AB_BDF_HALFSTEP_KEY,

          euler_forward_heun        = EULER_FORWARD_HEUN_KEY,
          heun_midpoint             = HEUN_MIDPOINT_KEY,
          midpoint_ralston          = MIDPOINT_RALSTON_KEY,
          ralston_radau             = RALSTON_RADAU_KEY,
          radau_rk44                = RADAU_RK44_KEY,
          rk44_gill44               = RK44_GILL44_KEY,
          rk44_rkm45                = RK44_RKM45_KEY,
          rk44_rkf456               = RK44_RKF456_KEY,
          rkm45_rkf456              = RKM45_RKF456_KEY,
          adams_bashforth_pece_ab_am  = ADAMS_BASHFORTH_PECE_AB_AM_KEY,
          adams_bashforth_pece_ab_bdf = ADAMS_BASHFORTH_PECE_AB_BDF_KEY,
          pece_ab_am_pece_ab_bdf      = PECE_AB_AM_PECE_AB_BDF_KEY
        },
        @default = rk44
      }, #method

      step_size =
      { @key = STEP_KEY,
        @type = @real,
        @default = 0.0001,
	@label = "step size",
	@tooltip = "Integration step size, if a integration method without step size adaption is used. Otherwise the maximal allowed integration step size."
      },

      array_name =
      { @key = BUTCHER_ARRAY_NAME_KEY,
        @type = @enum,
	@label = "array name",
	@tooltip = "Name of the Butcher array.",
        @enum =
        { euler_forward = EULER_FORWARD_KEY,
          euler_backward = EULER_BACKWARD_KEY,
          heun = HEUN_KEY,
          midpoint = MIDPOINT_KEY,
          ralston = RALSTON_KEY,
          radau = RADAU_KEY,
          rk44 = RK44_KEY,
          gill44 = GILL44_KEY,
          rkm45 = RKM45_KEY,
          rkf456 = RKF456_KEY,
          vern568 = VERN568_KEY,
          vern6710 = VERN6710_KEY,
          sharp6712 = SHARP6712_KEY,
          dopri7813 = DOPRI7813_KEY,
          user_defined = USER_DEFINED_KEY
        },
        @default = sharp6712
      }, #array_name

# --- BUTCHER ARRAY ----------------------------

      butcher_order_is_known =
      { @key = BUTCHER_ORDER_IS_KNOWN_KEY,
        @type = @boolean,
        @default = false,
	@label = "butcher order is known",
	@tooltip = "If the order of the Butcher array is known, a better step size adaption is possible."
      },

      butcher_order =
      { @key = BUTCHER_ORDER_KEY,
        @type = @integer,
        @min = 1,
	@label = "butcher order",
	@tooltip = "Order of the Butcher array."

      },

      nominators_array =
      { @key = NOMINATORS_ARRAY_DATA_KEY,
        @type = @array,
        @depth = 1,
        @element = {@type = @real},
        @dynamic = yes,
	@label = "nominators array",
	@tooltip = "Nominators of the Butcher array"
      },

      denominators_array =
      { @key = DENOMINATORS_ARRAY_DATA_KEY,
        @type = @array,
        @depth = 1,
        @element = {@type = @real},
        @default = (1, 1),
	@label = "denominators array",
	@tooltip = "Denominators of the Butcher array."
      },

# --- backward integrators ---------------

      backward_threshold =
      { @key = BACKWARD_THRESHOLD_KEY,
        @type = @real,
        @default = 1.0e-8,
	@label = "backward threshold",
	@tooltip = "Threshold for implicit integration methods."
      },

      bdf_order =
      { @key = BDF_ORDER_KEY,
        @type = @integer,
        @default = 6,
        @min = 1,
        @max = 7,
	@label = "bdf order",
	@tooltip = "Order of the backward differentiation formula."
      },

      adams_moulton_order =
      { @key = ADAMS_MOULTON_ORDER_KEY,
        @type = @integer,
        @default = 6,
        @min = 1,
        @max = 7,
	@label = "adams moulton order",
	@tooltip = "Order of the Adams-Moulton method."
      },

# --- integrators with fixed step size and with memory ----------

      adams_bashforth_order =
      { @key = ADAMS_BASHFORTH_ORDER_KEY,
        @type = @integer,
        @default = 6,
        @min = 1,
        @max = 7,
	@label = "adams bashforth order",
	@tooltip = "Order of the Adams-Bashforth method."
      },

# --- manhattan ---------------------------

      manhattan_threshold =
      { @key = MANHATTAN_THRESHOLD_KEY,
        @type = @real,
        @default = 1.0e-2,
	@label = "manhattan threshold",
	@tooltip = "Threshold for the gradient-based step size adaption."
      },

# --- halfstep ---------------------------

      integration_accuracy =
      { @key = INTEGRATION_ACCURACY_KEY,
        @type = @real,
        @default = 1.0e-6,
	@label = "integration accuracy",
	@tooltip = "Threshold for the halfstep-based step size adaption."
      },

      variables_weighting =
      { @key = VARIABLES_WEIGHTING_ARRAY_KEY,
        @type = @array,
        @depth = 1,
        @element = {@type = @real, @default = 1.0},
	@label = "variables weighting",
	@tooltip = "Weighting of specific variables for step size adaption."
      }
    }
  }, # integration

# --- PoincareMaps ---------------------------


  inside =
  { @key = DYNAMICAL_SYSTEM_INSIDE_KEY,
    @type = @record,
    @tooltip = "Description of the dynamical system inside the Poincare map.",
    @record =
    { dynamical_system  =
      { @key = DYNAMICAL_SYSTEM_KEY,
        @type = @like,
        @like = (dynamical_system),
	@label = "dynamical system",
        @tooltip = "Description of the dynamical system inside the Poincare map."
      }
    }
  },

  poincare_section =
  { @key = SECTION_DESCRIPTION_KEY,
    @type = @record,
    @label = "poincare section",
    @tooltip = "Description of the Poincare section describes the condition, which must be fulfilled by inside dynamical system, like crossing a plain, etc.",
    @record =
    { type =
      { @key = TYPE_KEY,
        @type = @enum,
        @enum =
        { fixed_plane               = FIXED_PLANE_KEY,
          parameter_dependent_plane = NOT_FIXED_PLANE_KEY,
          user_defined              = USER_DEFINED_KEY,
          min_max_points            = MIN_MAX_KEY,
          max_points                = MAX_KEY,
          min_points                = MIN_KEY,
          change_of_hybrid_state    = HYBRID_STATE_CHANGING_KEY
        },
        @default = fixed_plane
      },

      plane_coefficients =
      { @key = PLANE_COEFF_KEY,
        @type = @array,
        @depth = 1,
        @element = {@type = @real},
	@label = "plane coefficients",
	@tooltip = "Plane coefficients in the Hesse normal form."
      },

      variable_index =
      { @key = VAR_INDEX_KEY,
        @type = @integer,
        @min = 0,
	@label = "variable index",
	@tooltip = "Index of the state variable for which the condition (min, max, or both states) must be fulfilled."
      },

      additional_parameters =
      { @key = ADDITIONAL_PARAMETERS_KEY,
        @type = @array,
        @depth = 1,
        @element = {@type = @real},
        @dynamic = yes,
	@label = "additional parameters",
	@tooltip = "Additional parameters of the function which define the condition of the Poincare map."
      }
    }
  }, #poincare_section

# --- Stochastical keys ---------------------------

  number_of_subsystems =
  { @key = NUMBER_OF_SUBSYSTEMS_KEY,
    @type = @integer,
    @min = 1,
    @label = "number of subsystems",
    @tooltip = "Number of stochastic systems which will be averaged"
  },

  number_of_noisy_variables =
  { @key = NUMBER_OF_NOISY_VARS_KEY,
    @type = @integer,
    @default = 0,
    @min = 0,
    @readonly = yes,
    @label = "number of noisy variables",
    @tooltip = "Number of variables for which noise will be added"
  },

  noisy_variable[] =
  { @key = NOISY_VARIABLE,
    @type = @record,
    @dynamic = yes,
    @label = "specific noisy variables",
    @tooltip = "Description of the noise which will be added to specific variables.",
    @record =
    { index =
      { @key = VAR_INDEX_KEY,
        @type = @integer,
        @min = 0,
	@tooltip = "Index of the state  variable"
      },

      type =
      { @key = TYPE_KEY,
        @type = @enum,
        @enum =
        { uniform = UNIFORM_TYPE_KEY,
          gauss = GAUSS_TYPE_KEY
        },
        @default = uniform
      },

      min =
      { @key = MIN_KEY,
        @type = @real,
        @default = 0.0
      },

      max =
      { @key = MAX_KEY,
        @type = @real,
        @default = 1.0
      },

      mean_value =
      { @key = MEAN_KEY,
        @type = @real,
        @default = 0.0,
	@label = "mean value"
      },

      standard_deviation =
      { @key = SDEV_KEY,
        @type = @real,
        @default = 1.0,
	@label = "standard deviation"
      },

      seed =
      { @key = SEED_KEY,
        @type = @integer,
        @default = 1234567,
        @min = 0
      }
    }
  } #noisy_variable[]
 }
}, # dynamical_system

# -----------------------------------------------
# --- Scan --------------------------------------
# -----------------------------------------------
scan =
{ @key = SCAN_KEY,
  @type = @record,
  @record =
  { type =
    { @key = SCAN_TYPE_KEY,
      @type = @enum,
      @enum =
      { nested_items = NESTED_ITEMS_KEY,
        nested_items_cas = NESTED_ITEMS_CAS_KEY
      },
      @default = nested_items
    },

    mode =
    { @key = MODE_KEY,
      @type = @integer,
      @default = 0,
      @min = 0,
      @label = "scan mode",
      @tooltip = "Dimension of the scan."
    },

    item[] =
    { @key = ITEM,
      @type = @record,
      @dynamic = no,
      @label = "specific scan items",
      @record =
      { type =
          { @key = ITEM_TYPE_KEY,
          @type = @enum,
          @enum =
          { real_linear = REAL_LIN_KEY,
            real_logarithmic = REAL_LOG_KEY,
            integer_linear = INT_LIN_KEY,
            integer_logarithmic = INT_LOG_KEY,
            real_linear_2d = REAL_LIN_TWO_DIM_KEY,
            real_elliptic_2d = REAL_ELLIPTIC_TWO_DIM_KEY,
            from_file = FROM_FILE_KEY
          },
          @default = real_linear
        }, #type

        points =
        { @key = POINTS_KEY,
          @type = @integer,
          @default = 600,
          @min = 1
        },

        min =
        { @key = MIN_KEY,
          @type = @real
        },

        max =
        { @key = MAX_KEY,
          @type = @real
        },

        first_min =
        { @key = MIN1_KEY,
          @type = @real
        },

        first_max =
        { @key = MAX1_KEY,
          @type = @real
        },

        second_min =
        { @key = MIN2_KEY,
          @type = @real
        },

        second_max =
        { @key = MAX2_KEY,
          @type = @real
        },

        min_angle =
        { @key = MIN_ANGLE_KEY,
          @type = @real
        },

        max_angle =
        { @key = MAX_ANGLE_KEY,
          @type = @real
        },

        first_axis =
        { @key = AXIS1_KEY,
          @type = @real
        },

        second_axis =
        { @key = AXIS2_KEY,
          @type = @real
        },

        first_center =
        { @key = CENTER1_KEY,
          @type = @real
        },

        second_center =
        { @key = CENTER2_KEY,
          @type = @real
        },

        object =
        { @key = OBJECT_KEY,
          @type = @string
        },

        first_object =
        { @key = OBJECT1_KEY,
          @type = @like,
          @like = (scan, item[], object)
        },

        second_object =
        { @key = OBJECT2_KEY,
          @type = @like,
          @like = (scan, item[], object)
        },

	external_data_filename =
	{ @key = EXTERNAL_DATA_FILENAME_KEY,
	  @type = @string,
	  @label = "external file name",
	  @tooltip = "Name of the data file, which contains the scan values."
	},

	number_of_columns =
	{ @key = NUMBER_OF_COLUMNS_KEY,
	  @type = @integer,
	  @min = 1,
	  @default = 1,
	  @label = "number of columns",
	  @tooltip = "Number of columns in the data file."
	},

	subitem[] =
	{ @key = SUBITEM,
	  @type = @record,
	  @dynamic = yes,
	  @label = "specific components",
	  @tooltip = "The components describe the correspondence between columns of the data file and the scannable objects",
	  @record =
	  { object =
	    { @key = OBJECT_KEY,
	      @type = @like,
	      @like = (scan, item[], object)
            },
	    column =
	    { @key = COLUMN_KEY,
	      @type = @integer,
	      @min = 1,
	      @default = 1
	    }
	  }
        }
      } #item (?)
    },

    cas =
    { @key = CAS_KEY,
      @type = @record,
      @dynamic = no,
      @label = "coexisting attractor scan",
      @record =
      { iss =
        { @key = ISS_KEY,
          @type = @record,
          @dynamic = no,
          @label = "initial state scan",
          @record =
          { type =
            { @key = SCAN_TYPE_KEY,
              @type = @enum,
              @enum =
              { nested_items = NESTED_ITEMS_KEY
              },
              @default = nested_items
            },

            mode =
            { @key = MODE_KEY,
              @type = @integer,
              @default = 0,
              @min = 0,
              @label = "scan mode",
              @tooltip = "Dimension of the scan."
            },

            item[] =
            { @key = ITEM,
              @type = @record,
              @dynamic = no,
              @label = "specific scan items",
              @record =
              { type =
                { @key = ITEM_TYPE_KEY,
                  @type = @enum,
                  @enum =
                  { real_linear = REAL_LIN_KEY,
                    real_logarithmic = REAL_LOG_KEY,
                    integer_linear = INT_LIN_KEY,
                    integer_logarithmic = INT_LOG_KEY,
                    real_linear_2d = REAL_LIN_TWO_DIM_KEY,
                    real_elliptic_2d = REAL_ELLIPTIC_TWO_DIM_KEY,
                    from_file = FROM_FILE_KEY
                  },
                  @default = real_linear
                }, #type

                points =
                { @key = POINTS_KEY,
                  @type = @integer,
                  @default = 600,
                  @min = 1
                },

                min =
                { @key = MIN_KEY,
                  @type = @real
                },

                max =
                { @key = MAX_KEY,
                  @type = @real
                },

                first_min =
                { @key = MIN1_KEY,
                  @type = @real
                },

                first_max =
                { @key = MAX1_KEY,
                  @type = @real
                },

                second_min =
                { @key = MIN2_KEY,
                  @type = @real
                },

                second_max =
                { @key = MAX2_KEY,
                  @type = @real
                },

                min_angle =
                { @key = MIN_ANGLE_KEY,
                  @type = @real
                },

                max_angle =
                { @key = MAX_ANGLE_KEY,
                  @type = @real
                },

                first_axis =
                { @key = AXIS1_KEY,
                  @type = @real
                },

                second_axis =
                { @key = AXIS2_KEY,
                  @type = @real
                },

                first_center =
                { @key = CENTER1_KEY,
                  @type = @real
                },

                second_center =
                { @key = CENTER2_KEY,
                  @type = @real
                },

                object =
                { @key = OBJECT_KEY,
                  @type = @string
                },

                first_object =
                { @key = OBJECT1_KEY,
                  @type = @like,
                  @like = (scan, item[], object)
                },

                second_object =
                { @key = OBJECT2_KEY,
                  @type = @like,
                  @like = (scan, item[], object)
            },

                external_data_filename =
                { @key = EXTERNAL_DATA_FILENAME_KEY,
                  @type = @string,
                  @label = "external file name",
                  @tooltip = "Name of the data file, which contains the scan values."
                },

                number_of_columns =
                { @key = NUMBER_OF_COLUMNS_KEY,
                  @type = @integer,
                  @min = 1,
                  @default = 1,
                  @label = "number of columns",
                  @tooltip = "Number of columns in the data file."
                },

                subitem[] =
                { @key = SUBITEM,
                  @type = @record,
                  @dynamic = yes,
                  @label = "specific components",
                  @tooltip = "The components describe the correspondence between columns of the data file and the scannable objects",
                  @record =
                  { object =
                    { @key = OBJECT_KEY,
                      @type = @like,
                      @like = (scan, cas, iss, item[], object)
                    },
                    column =
                    { @key = COLUMN_KEY,
                      @type = @integer,
                      @min = 1,
                      @default = 1
                    }
                  }
                }
              }
            }
          }
        },

        steps_between_iss =
        { @key = STEPS_BETWEEN_ISS_KEY,
          @type = @integer,
          @default = 10,
          @label = "steps between iss",
          @tooltip = "Number of scan steps between two executions of the initial state scan."
        },

        max_backtrack_depth =
        { @key = MAX_BACKTRACK_DEPTH_KEY,
          @type = @boolean,
          @default = true,
          @label = "complete backtrack",
	  @tooltip = "Backtrack up to the start of the current scan line."
        },

        backtrack_depth =
        { @key = BACKTRACK_DEPTH_KEY,
          @type = @integer,
          @default = 0,
          @label = "maximum backtracking depth"
        },

        iss_iterations =
        { @key = ISS_ITERATIONS_KEY,
          @type = @integer,
          @default = 10000,
          @label = "number of iss iterations",
          @tooltip = "Number of iterations to calculate during the initial state scan."
        },

        transient_steps =
        { @key = TRANSIENT_STEPS_KEY,
          @type = @integer,
          @default = 5000,
          @min = 0,
          @label = "number of transient steps"
        },

	reset_from_iss_orbit =
	{ @key = RESET_FROM_ISS_ORBIT_KEY,
	  @type = @boolean,
	  @default = true,
	  @label = "reset from iss orbit",
	  @tooltip = "Use the iterated orbit of the iss simulator as initial values for the main simulator"
	},

        min_max =
        { @key = MIN_MAX_KEY,
          @type = @boolean,
          @default = true,
          @label = "min/max"
        },

        infinity_threshold =
        { @key = INFINITY_THRESHOLD_KEY,
          @type = @real,
          @default = 1.0e5,
          @min = 0,
          @label = "threshold for divergent orbits"
        },

        regular_compare_precision =
        { @key = REGULAR_COMPARE_PRECISION_KEY,
         @type = @real,
          @default = 1.0e-8,
          @min = 0,
          @label = "regular compare precision",
	  @tooltip = "Normally used to compare min/max values."
        },

        reduced_compare_precision =
        { @key = REDUCED_COMPARE_PRECISION_KEY,
          @type = @real,
          @default = 1.0e-1,
          @min = 0,
          @label = "reduced compare precision",
	  @tooltip = "Used instead of the regular compare precision for chaotic attractors in discrete systems."
        },
            
        max_period =
        { @key = MAX_PERIOD_KEY,
          @type = @integer,
          @default = 128,
          @min = 1,
          @label = "maximum period to detect"
        }
      }
    }
  }
}, # scan

# -----------------------------------------------
# --- Investigation Methods ---------------------
# -----------------------------------------------

investigation_methods =
{ @key = INVESTIGATION_METHODS_KEY,
  @type = @record,
  @label = "investigation methods",
  @tooltip = "Description of the investigation methods, which will be applied. Note, that it is more easy to avoid some conflicts, if you edit the settings for the dynamical system and scan description firstly, an the settings for the investigation methods after that.",
  @record =

# -----------------------------------------------
# --- General Trajectory Evaluations ------------
# -----------------------------------------------

  { general_trajectory_evaluations =
    { @key = GENERAL_ANALYSIS_KEY,
      @optional = yes,
      @type = @record,
      @label = "general trajectory evaluations",
      @tooltip = "General trajectory evaluations include saving, velocity calculation, basic statistics and something more.", 
      @record =
      { is_active =
        { @key = IS_ACTIVE_KEY,
	  @label = "is active",	
	  @tooltip = "Activate the method",  
          @type = @boolean,
          @default = false
        },

        transient =
        { @key = TRANSIENT_KEY,
          @type = @integer,
          @default = 0,
	  @label = "transient",  
	  @tooltip = "Number of transient steps. A common value for all parts of the general trajectory evaluations.",
          @min = 0
        },


# --- saving ---------------------------

        saving =
        { @key = SAVING_KEY,
          @type = @record,
	  @optional = yes,
	  @label = "basic saving",  
	  @tooltip = "saving of the trajectory (time series, velocities, phase portraits)",
          @record =
          { is_active =
            { @key = IS_ACTIVE_KEY,
	      @label = "is active",	
	      @tooltip = "Activate the method",  
              @type = @boolean,
              @default = false
            },

            type =
            { @key = SAVING_TYPE_KEY,
              @type = @enum,
	      @label = "type",  
	      @tooltip = "There are two basic types of the saving. The time oriented saving means, that the states are saved equidistant in the time. The space oriented saving means, that the orbit will be saved approximative equidistant in the state space and the current velocities will be saved approximative equidistant in the velocity space.",
              @enum =
              { time_oriented = TIME_ORIENTED_TYPE_KEY,
                space_oriented = SPACE_ORIENTED_TYPE_KEY
              },
              @default = time_oriented
            },

            policy =
            { @key = SAVING_POLICY_KEY,
              @type = @enum,
	      @label = "policy",  
	      @tooltip = "For spatial inhomogeneous system classes there are two basic policies the saving. The state oriented saving means, that the complete state (all spatial cells) are saved within a single row in the data file. The cell oriented saving means, that each cell will be saved separately.",
              @enum =
              { state_oriented = STATE_ORIENTED_POLICY_KEY,
                cell_oriented = CELL_ORIENTED_POLICY_KEY
              },
              @default = state_oriented
            },

            points_step =
            { @key = POINTS_STEP_KEY,
              @type = @integer,
              @default = 1,
	      @label = "points step",  
	      @tooltip = "If the point step is set to the value N, then each N-th point will be saved.",
              @min = 1
            },

            state_space_distance =
            { @key = STATE_SPACE_SAVING_DISTANCE_KEY,
	      @label = "state space distance",  
	      @tooltip = "The distance between two subsequent saved points in the state space will be not less than this distance.",
              @type = @real
            },

            velocity_space_distance =
            { @key = VELOCITY_SPACE_SAVING_DISTANCE_KEY,
	      @label = "velocity space distance",  
	      @tooltip = "The distance between two subsequent saved points in the velocity space will be not less than this distance.",
              @type = @real
            },

            trajectory =
            { @key = TRAJECTORY_KEY,
              @type = @boolean,
	      @tooltip = "Saving of the current trajectory.",
              @default = true
            },

            trajectory_file =
            { @key = TRAJECTORY_FILE_KEY,
              @type = @string,
	      @label = "trajectory file",  
              @default = "orbit.tna"
            },

            cobweb =
            { @key = COBWEB_KEY,
              @type = @boolean,
	      @tooltip = "Saving of the current trajectory in the cobweb diagram format.",
              @default = false
            },

            cobweb_file =
            { @key = COBWEB_FILE_KEY,
              @type = @string,
	      @label = "cobweb diagram file",  
              @default = "cobweb.tna"
            },

            velocity =
            { @key = VELOCITY_KEY,
              @type = @boolean,
	      @tooltip = "Saving of the current velocity.",
              @default = false
            },

            current_velocity_file =
            { @key = CURRENT_VELOCITY_FILE_KEY,
              @type = @string,
	      @label = "current velocity file",  
              @default = "orbital_velocity.tna"
            },

            phase_portrait =
            { @key = PHASE_PORTRAIT_KEY,
              @type = @boolean,
	      @label = "phase portrait",  
	      @tooltip = "Saving of the current trajectory and the current velocity in the same file.",	      
              @default = false
            },

            phase_portrait_file =
            { @key = PHASE_PORTRAIT_FILE_KEY,
              @type = @string,
	      @label = "phase portrait file.",  
              @default = "phase_portrait.tna"
            },

            initial_states =
            { @key = SAVE_INITIAL_STATES_KEY,
              @type = @boolean,
	      @label = "initial states",
	      @tooltip = "initial states of the trajectory",
              @default = false
            },

            initial_states_file =
            { @key = INITIAL_STATES_FILE_KEY,
              @type = @string,
	      @label = "initial states file",
              @default = "initial_states.tna"
            },

            save_only_specific_area =
            { @key = SAVE_ONLY_SPECIFIC_AREA_KEY,
              @type = @boolean,
	      @label = "save only specific area",
	      @tooltip = "Save only points which lie in a given area (state space or velocity space). This option may be useful on order to produce of blowups.",
              @default = false
            },

            state_space_saving_area =
            { @key = STATE_SPACE_SAVING_AREA_KEY,
              @type = @array,
	      @label = "state space saving area",  
	      @tooltip = "For each state variable the lower and the upper saving range in the state space must be specified.",
              @depth = 2,
              @element = {@type = @real}
            },

            velocity_space_saving_area =
            { @key = VELOCITY_SPACE_SAVING_AREA_KEY,
              @type = @array,
	      @label = "velocity space saving area",  
	      @tooltip = "For each state variable the lower and the upper saving range in the velocity space must be specified.",
              @depth = 2,
              @element = {@type = @real}
            }
          }
        }, #saving


# --- min_max_values ---------------------------

        min_max_values =
        { @key = MIN_MAX_VALUES_KEY,
          @type = @record,
	  @label = "min/max values",
	  @tooltip = "Minimal and maximal values of the trajectory",
	  @optional = yes,
          @record =
          { is_active =
            { @key = IS_ACTIVE_KEY,
	      @label = "is active",	
	      @tooltip = "Activate the method",  
              @type = @boolean,
              @default = false
            },

            min_vals_file =
            { @key = MIN_VALS_FILE_KEY,
              @type = @string,
	      @label = "minimal values file",
              @default = "min.tna"
            },

            max_vals_file =
            { @key = MAX_VALS_FILE_KEY,
              @type = @string,
	      @label = "maximal values file",
              @default = "max.tna"
            }
          }
        },

# --- wave numbers ---------------------------

        wave_numbers =
        { @key = WAVE_NUMBERS_KEY,
          @type = @record,
	  @optional = yes,
	  @label = "wave numbers",
	  @tooltip = "Wave numbers",
          @record =
          { is_active =
            { @key = IS_ACTIVE_KEY,
	      @label = "is active",	
	      @tooltip = "Activate the method",  
              @type = @boolean,
              @default = false
            },

            wave_numbers_file =
            { @key = WAVE_NUMBERS_FILE_KEY,
              @type = @string,
	      @label = "wave numbers file",
              @default = "wave_number.tna"
            }

          }
        }, #wave_numbers


# --- statistics ---------------------------

        statistics =
        { @key = STATISTICS_KEY,
          @type = @record,
	  @optional = yes,
          @record =
          { is_active =
            { @key = IS_ACTIVE_KEY,
	      @label = "is active",	
	      @tooltip = "Activate the method",  
              @type = @boolean,
              @default = false
            },

            mean_value =
            { @key = MEAN_VALUE_KEY,
              @type = @boolean,
	      @label = "mean value",
	      @tooltip = "Mean value of the trajectory.",
              @default = false
            },

            mean_value_file =
            { @key = MEAN_VALUE_FILE_KEY,
              @type = @string,
	      @label = "mean value file",
              @default = "mean_value.tna"
            },

            standard_deviation =
            { @key = STANDARD_DEVIATION_KEY,
              @type = @boolean,
	      @label = "standard deviation",
	      @tooltip = "Standard deviation of the trajectory.",
              @default = false
            },

            standard_deviation_file =
            { @key = STANDARD_DEVIATION_FILE_KEY,
              @type = @string,
	      @label = "standard deviation file",
              @default = "standard_deviation.tna"
            },

            average_velocity =
            { @key = AVERAGE_VELOCITY_KEY,
              @type = @boolean,
	      @label = "average velocity",
	      @tooltip = "Average velocity.",
              @default = false
            },

            average_velocity_file =
            { @key = AVERAGE_VELOCITY_FILE_KEY,
              @type = @string,
	      @label = "average velocity file",
              @default = "average_velocity.tna"
            },

            correlation_coefficient =
            { @key = CORRELATION_COEFFICIENT_KEY,
              @type = @boolean,
	      @label = "correlation coefficients",
	      @tooltip = "Cross correlation coefficients.",
              @default = false
            },

            correlation_coefficient_file =
            { @key = CORRELATION_COEFFICIENT_FILE_KEY,
              @type = @string,
	      @label = "correlation coefficient file",
              @default = "correlation_coefficient.tna"
            }
          }
        },

# --- pgm_output ---------------------------

        pgm_output =
        { @key = PGM_OUTPUT_KEY,
          @type = @record,
	  @optional = yes,
	  @label = "pgm output",
	  @tooltip = "Saving of the trajectory as a gray scale landscape. Maintained mostly for spatial inhomogeneous dynamical systems.",
          @record =
          { is_active =
            { @key = IS_ACTIVE_KEY,
	      @label = "is active",	
	      @tooltip = "Activate the method",  
              @type = @boolean,
              @default = false
            },

            points_step =
            { @key = PGM_OUTPUT_STEP_KEY,
              @type = @integer,
              @default = 1,
              @min = 1
            },

            number_of_pictures =
            { @key = PGM_OUTPUT_PICTURES_NUMBER_KEY,
              @type = @integer,
              @default = 0,
              @min = 0,
	      @label = "number of pictures",
              @readonly = yes
            },

            picture[] =
            { @key = PGM_OUTPUT_PICTURE_KEY,
              @type = @record,
	      @label = "spacific pictures",
              @dynamic = yes,
	      @tooltip = "Description of specific pictures (start and stop time)",
              @record =
              { start =
                { @key = PGM_OUTPUT_START_KEY,
                  @type = @integer,
                  @default = 0,
                  @min = 0,
		  @label = "start time"
                },

                stop =
                { @key = PGM_OUTPUT_STOP_KEY,
                  @type = @integer,
                  @default = 1,
                  @min = 1,
		  @label = "stop time"
                }
              }
            }, #picture[]

            pgm_output_file =
            { @key = PGM_OUTPUT_FILE_KEY,
              @type = @string,
              @default = "fig",
	      @label = "output file prefix",
	      @tooltip = "Names of the output files will be created using this prefix concatinated with the index of the state variable and the index of the picture."
            }
          }
        } #pgm_output
      }#
    }, #general_trajectory_evaluations

# -----------------------------------------------
# --- Spatial Evaluations------------------------
# -----------------------------------------------
    spatial_evaluations =
    { @key = SPATIAL_EVALUATION_KEY,
      @optional = yes,
      @label = "spatial trajectory evaluations",
      @tooltip = "Determining of the spatial mean values etc. for spatial inhomogeneous dynamical systems",
      @type = @record,
      @record =
      { is_active =
        { @key = IS_ACTIVE_KEY,
	  @label = "is active",	
	  @tooltip = "Activate the method",  
          @type = @boolean,
          @default = false
        },

      transient =
      { @key = TRANSIENT_KEY,
        @type = @integer,
        @default = 0,
	@label = "transient",  
	@tooltip = "Number of transient steps.",
        @min = 0
      },

      points_step =
      { @key = POINTS_STEP_KEY,
        @type = @integer,
        @default = 1,
        @label = "points step",  
        @tooltip = "If the point step is set to the value N, then only each N-th point will be evaluated.",
        @min = 1
      },

      mean_value =
      { @key = MEAN_VALUE_KEY,
        @type = @boolean,
	@label = "mean value",
	@tooltip = "spatial mean value (over all cells) will be calculated for each componente of the cell in each step, specified by options 'transient' and 'points step'.",
        @default = true
      },

      mean_value_file =
      { @key = MEAN_VALUE_FILE_KEY,
        @type = @string,
	@label = "mean value file",
	@tooltip = "output file for the spatial mean values",
        @default = "spatial_mean_value.tna"
      },

      standard_deviation =
      { @key = STD_DEVIATION_KEY,
        @type = @boolean,
	@label = "standard deviation",
	@tooltip = "spatial standard deviation (over all cells) will be calculated for each componente of the cell in each step, specified by options 'transient' and 'points step'.",
        @default = true
      },

      standard_deviation_file =
      { @key = STD_DEVIATION_FILE_KEY,
        @type = @string,
	@label = "standard_deviation file",
	@tooltip = "output file for the spatial standard deviation",
        @default = "standard_deviation.tna"
      },

      average_correlation =
      { @key = AVERAGE_CORRELATION_KEY,
        @type = @boolean,
	@label = "average correlation",
	@tooltip = "the correlation (over all cells) will be calculated and averaged for each componente of the cell in each step, specified by options 'transient' and 'points step'.",
        @default = true
      },

      average_correlation_file =
      { @key = AVERAGE_CORRELATION_FILE_KEY,
        @type = @string,
	@label = "average correlation file",
	@tooltip = "output file for the average spatial correlation",
        @default = "average_correlation.tna"
      },

      wave_numbers =
      { @key = WAVE_NUMBERS_KEY,
        @type = @boolean,
	@label = "wave numbers",
	@tooltip = "spatial wave numbers (over all cells) will be calculated for each componente of the cell in each step, specified by options 'transient' and 'points step'.",
        @default = false
      },

      wave_numbers_file =
      { @key = WAVE_NUMBERS_FILE_KEY,
        @type = @string,
	@label = "wave numbers file",
	@tooltip = "output file for the spatial wave numbers",
        @default = "spatial_wave_numbers.tna"
      },

      compare_precision =
      { @key = CMP_PRECISION_KEY,
        @type = @real,
        @label = "compare precision",
        @tooltip = "For the calculation of wave numbers the local max values must be found. These will be detected if the difference between neighbor cells is not less than this value.",
        @default = 1.0e-6,
        @min = 0
      },

      save_only_final =
      { @key = SAVE_ONLY_FINAL_KEY,
        @type = @boolean,
      	    @label = "save only final results",
      	    @tooltip = "Do not save the results to each step, but the final results only. This option is useful if you perform a scan",
        @default = false
      },

      specific_counter[] =
      { @key = COUNTER,
        @type = @record,
        @dynamic = yes,
        @label = "cell counters",
        @record =
        { 
          type = 
          {
            @key = TYPE_KEY,
            @type = @enum,
            @enum = { cells_within_range = CELLS_WITHIN_RANGE_KEY,
                      stationary_cells = STATIONARY_CELLS_KEY,
                      periodic_cells = PERIODIC_CELLS_KEY,
                      user_defined = USER_DEFINED_KEY,
                      plateaus = PLATEAUS_KEY
                    }
          },

          output_file =
          { @key = FILE_KEY,
            @type = @string,
	    @label = "output file",
	    @tooltip = "output file for the number of cells that fulfill the specific condition",
            @default = "number_of_cells.tna"
          },

          ranges =
            { @key = RANGES_KEY,
              @type = @array,
	      @label = "ranges for a cell",  
	      @tooltip = "For each state variable of a cell the lower and the upper saving range in the state space must be specified.",
              @depth = 2,
              @element = {@type = @real}
            },

          period =
          { @key = PERIOD_KEY,
            @type = @integer,
	    @label = "period",
	    @tooltip = "Period to be detected for a specific cell",
            @default = 2,
            @min = 2
          },

          compare_precision =
          { @key = CMP_PRECISION_KEY,
            @type = @real,
	    @label = "compare precision",
	    @tooltip = "Two cell components will be assumed to be identical if the distance inbetween is less than this value.",
            @default = 1.0e-8,
            @min = 0
          },

          name =
          { @key = NAME_KEY,
            @type = @string,
	    @label = "function name",
	    @tooltip = "The name, for which the function is registered (in the .cpp file). BE CAREFUL! Use exactly the same name as registered!"
# do not specify any default value! The user should do it corresponding to
# his .cpp file
          },

          states_in_the_past =
          { @key = NEEDED_STATES_KEY,
            @type = @integer,
	    @label = "states in the past",
	    @tooltip = "Number of states in the past, needed in order to evaluate the user-defined counter function. If you use states in the past, and not specifie it here, the simulator may crash. If you don't use these states, the default value zero is acceptable for you.",
            @default = 0,
            @min = 0
          },

          parameters =
          { @key = PARAMETERS_KEY,
            @type = @array,
            @depth = 1,
            @optional = yes,
	    @label = "additional parameters",
            @element = {@type = @real},
            @dynamic = yes
          }
	}
      }
     }
    },	

# -----------------------------------------------
# --- Period Analysis ---------------------------
# -----------------------------------------------

    period_analysis =
    { @key = PERIOD_ANALYSIS_KEY,
      @optional = yes,
      @label = "period analysis",
      @tooltip = "Determining of the period, saving of the bifurcation diagrams, etc.",
      @type = @record,
      @record =
      { is_active =
        { @key = IS_ACTIVE_KEY,
	  @label = "is active",	
	  @tooltip = "Activate the method",  
          @type = @boolean,
          @default = false
        },

        max_period =
        { @key = MAX_PERIOD_KEY,
          @type = @integer,
          @default = 128,
	  @label = "maximal period",
	  @tooltip = "Maximal period to be detected",
          @min = 1
        },

        compare_precision =
        { @key = DISCRETE_COMPONENTS_CMP_PRECISION_KEY,
          @type = @real,
	  @label = "compare precision",
	  @tooltip = "Two states will be assumed to be identical if the distance inbetween is less than this value.",
          @default = 1.0e-8
        },

        period =
        { @key = PERIOD_KEY,
          @type = @boolean,
	  @label = "period",
          @default = false
        },

        period_file =
        { @key = PERIOD_FILE_KEY,
          @type = @string,
	  @label = "period file",
          @default = "period.tna"
        },

        cyclic_asymptotic_set =
        { @key = CYCLIC_BIF_DIA_KEY,
          @type = @boolean,
	  @label = "cyclic asymptotic set",
	  @tooltip = "Periodic part of the bifurcation diagram. States with period up to 'maximal period' will be saved.",
          @default = false
        },

        cyclic_bif_dia_file =
        { @key = CYCLIC_BIF_DIA_FILE_KEY,
          @type = @string,
	  @label = "cyclic asymptotic set file",
          @default = "bif_cyclic.tna"
        },

        acyclic_last_states =
        { @key = ACYCLIC_BIF_DIA_KEY,
          @type = @boolean,
	  @label = "acyclic asymptotic set",
	  @tooltip = "Aperiodic part of the bifurcation diagram. Last states of the trajectory will be saved, the number of the last states to be saved is given by the 'using last points' field.",
          @default = false
        },

        acyclic_bif_dia_file =
        { @key = ACYCLIC_BIF_DIA_FILE_KEY,
          @type = @string,
	  @label = "acyclic asymptotic set file",
          @default = "bif_acyclic.tna"
        },

        cyclic_graphical_iteration =
        { @key = CYCLIC_GRAPH_ITER_KEY,
          @type = @boolean,
	  @label = "cyclic cobweb",
          @default = false
        },

        cyclic_graph_iter_file =
        { @key = CYCLIC_GRAPH_ITER_FILE_KEY,
          @type = @string,
	  @label = "cyclic cobweb file",
          @default = "cyclic_cobweb.tna"
        },

        acyclic_graphical_iteration =
        { @key = ACYCLIC_GRAPH_ITER_KEY,
          @type = @boolean,
	  @label = "acyclic cobweb",
          @default = false
        },

        acyclic_graph_iter_file =
        { @key = ACYCLIC_GRAPH_ITER_FILE_KEY,
          @type = @string,
	  @label = "acyclic cobweb file",
          @default = "acyclic_cobweb.tna"
        },

        using_last_points =
        { @key = USING_LAST_POINTS_KEY,
          @type = @integer,
          @default = 128,
	  @label = "using last points",
	  @tooltip = "Number of the trajectory last states, which are used by saving of the acyclic asymptotic stets and acyclic cobwebs.", 
          @min = 1
        },

        period_selections =
        { @key = PERIOD_SELECTION_KEY,
          @type = @boolean,
	  @label = "period selections",
	  @tooltip = "Settings leading to a given period.",
          @default = false
        },

        periods_to_select =
        { @key = PERIODS_TO_SELECT_KEY,
          @type = @array,
          @depth = 1,
	  @label = "periods to select",
          @element = {@type = @integer, @min = 1},
          @dynamic = yes
        },

        period_selection_file =
        { @key = PERIOD_SELECTION_FILE_KEY,
          @type = @string,
	  @label = "period selection file prefix",
          @default = "period_selection"
        },

        period_selection_file_extension =
        { @key = PERIOD_SELECTION_EXT_KEY,
          @type = @string,
	  @label = "period selection file extension",
          @default = "tna"
        }
      }
    }, #periodAnalysis

# -----------------------------------------------
# --- BandCounter -------------------------------
# -----------------------------------------------

    band_counter =
    { @key = BAND_COUNTER_KEY,
      @label = "band counter",
      @tooltip = "Determining the number of bands of a chaotic attractor.",
      @optional = yes,
      @type = @record,
      @record =
      { is_active =
        { @key = IS_ACTIVE_KEY,
          @label = "is active",
          @tooltip = "Activate the method",
          @type = @boolean,
          @default = false
        },

        method =
        { @key = METHOD_SELECTION_KEY,
          @type = @enum,
          @label = "method",
          @tooltip = "Select the method.    The GCD-based method is faster and more precise. But this method works only when the orbit of the chaotic attraktor hits the bands periodically, which is the case for dynamical systems with continuous system functions.     The box-counting-based method works for all systems but needs more memory and more iterations. It was developed to examine dynamical systems with non-continuous system functions.",
          @enum =
            { gcd_based = METHOD_1_KEY,
              box_counting_based = METHOD_2_KEY
            },
          @default = gcd_based
        },

        transient =
        { @key = TRANSIENT_KEY,
          @type = @integer,
          @default = 1000,
          @label = "transient",
          @tooltip = "Number of transient steps.",
          @min = 0
        },

        max_bandcount =
        { @key = MAX_BANDCOUNT_KEY,
          @label = "max bandcount",
          @tooltip = "Maximum of bands counted.",
          @type = @integer,
          @default = 128,
          @min = 0
        },

        period_compare_precision =
        { @key = PERIOD_CMP_PRECISION_KEY,
          @type = @real,
          @label = "period compare precision",
          @tooltip = "Used to determine if periodic or chaotic attractor.  Two states will be assumed to be identical if the distance inbetween is less than this value.",
          @default = 1.0e-8,
          @min = 0
        },

# --- begin method 1 ----------------------

        bandcount_compare_precision =
        { @key = M1_COMPARE_CLOSENESS_KEY,
          @label = "bandcount compare precision",
          @tooltip = "Closeness of two points when they definitively belong to one band.  Must be smaller than the gap between two different bands.",
          @type = @real,
          @default = 1.0e-6
        },

        basis_points =
        { @key = M1_COMPARE_QUANTITY_KEY,
          @label = "basis points",
          @tooltip = "Number of orbit points which are used as basis for comparision.",
          @type = @integer,
          @default = 1000,
          @min = 1
        },

        fast_termination =
        { @key = M1_FAST_MODE_KEY,
          @label = "fast termination",
          @tooltip = "Activates fast termination mode. Termination can be controlled by the value entered in termination_after.",
          @type = @boolean,
          @default = false
        },

        termination_after =
        { @key = M1_UNCHANGED_BOUND_KEY,
          @label = "termination after",
          @tooltip = "Assumes to have found the right bandcount, when the bandcount did not change after this much iterations, when the previous band count was the same. Speeds up the algotithm, but low values may lead to incorrect results.",
          @type = @integer,
          @default = 50
        },

# --- end method 1 ----------------------

# --- begin method 2 --------------------

        automatic_domain_detection =
        { @key = M2_AUTO_BOUND_BOX_KEY,
          @label = "automatic domain detection",
          @tooltip = "Calculate boundaries automatically.  Make sure the transient is big enough (at least 500).  If turned off, the boundaries have to be specified manually.",
          @type = @boolean,
          @default = true
        },

        domain_boundaries =
        { @key = M2_BOUND_BOX_KEY,
          @type = @array,
          @label = "domain boundaries",
          @tooltip = "Specify boundaries manually.  Upper line are the min-values, lower line the max-values.  The colums from left to right are the state space variables (x, y, z, ...).",
          @depth = 2,
          @element = {@type = @real},
          @default = ((0.0, 1.0),(0.0, 1.0))
        },

        number_of_boxes =
        { @key = M2_PARTITIONS_KEY,
          @label = "number of boxes",
          @tooltip = "Number of boxes per dimension.",
          @type = @array,
          @depth = 1,
          @element = {@type = @integer, @default = 1000}
        },

        error_threshold =
        { @key = M2_REMOVE_PERCENT_KEY,
          @label = "error threshold",
          @tooltip = "After calculation the clusters with less then this percentage of the mean value of all clusters will be removed. The count of all remaining clusters will be the band count.  This may lead to much results, because small errors will be eliminated. But when investigating none-continuous systems it will probably remove real bands instead of errors. Better use a larger transient.",
          @type = @integer,
          @min = 0,
          @max = 100,
          @default = 0
        },
	
        use_hash =
        { @key = M2_USE_HASH,
          @label = "use hash",
          @tooltip = "Use a hash instead of an array. Slower but consumes much less memory. Suitable for 2- or more-dimensional systems.",
          @type = @boolean,
          @default = false
        },
	
        hash_size =
        { @key = M2_HASH_SIZE,
          @label = "hash size",
          @tooltip = "If set to zero (0), a default value based on the number of iterations will be set.",
          @type = @integer,
          @default = 0,
          @min = 0
        },

# --- end method 2 --------------------------

        period =
        { @key = SAVE_PERIOD_KEY,
          @label = "period",
          @tooltip = "Activate to save a period file.",
          @type = @boolean,
          @default = false
        },

        period_file =
        { @key = PERIOD_FILE_KEY,
          @label = "period file",
          @tooltip = "Output file for period.",
          @type = @string,
          @default = "bandcount_period.tna"
        },

        bandcount_file =
        { @key = BANDCOUNT_FILE_KEY,
          @label = "bandcount file",
          @tooltip = "Output file for bandcount.",
          @type = @string,
          @default = "bandcount.tna"
        }

       }
     }, #band_counter

# -----------------------------------------------
# --- Symbolic Analysis -------------------------
# -----------------------------------------------

    symbolic_analysis =
    { @key = SYMBOLIC_ANALYSIS_KEY,
      @optional = yes,
      @label = "symbolic analysis",
      @tooltip = "Symbolic sequence analysis",
      @type = @record,
      @record =
      { is_active =
        { @key = IS_ACTIVE_KEY,
	  @label = "is active",	
	  @tooltip = "Activate the method",  
          @type = @boolean,
          @default = false
        },

        symbolic_function =
        { @key = SYMBOLIC_FUNCTION_KEY,
          @type = @enum,
	  @label = "symbolic function",
	  @tooltip = "Type of the function for the state space partition.",
          @enum =
          { using_<L/R>_symbolic_dynamics = USING_LR_KEY,
            using_<+/->_symbolic_dynamics = USING_PM_KEY,
            using_user_defined_symbolic_dynamics = USING_USER_DEF_KEY,
            according_to_hybrid_state = USING_HYBRID_STATE_KEY
          },
          @default = using_<L/R>_symbolic_dynamics
        },

        critical_points_for_<L/R>_symbolic_dynamics =
        { @key = LR_C_VALUES_KEY,
          @type = @array,
	  @label = "critical points",
	  @tooltip = "Partition border for the (L/R) symbolic dynamics.",
          @depth = 1,
          @element = {@type = @real}
        },

# hier weitermachen

        transient =
        { @key = TRANSIENT_KEY,
          @type = @integer,
          @default = 0,
          @min = 0
        },

        symbolic_description_level =
        { @key = SYMBOLIC_DESCRIPTION_LEVEL_KEY,
          @type = @integer,
          @default = 5,
          @min = 1
        },

        symbolic_entropy_approximate =
        { @key = ENTR_A_KEY,
          @type = @boolean,
          @default = false
        },

        symb_entr_a_file =
        { @key = SYMB_ENTR_A_FILE_NAME_KEY,
          @type = @string,
          @default = "symbolic_entropy_approximate.tna"
        },

        symbolic_probability_approximate =
        { @key = PROB_A_KEY,
          @type = @boolean,
          @default = false
        },

        symb_prob_a_file =
        { @key = SYMB_PROB_A_FILE_NAME_KEY,
          @type = @string,
          @default = "symbolic_probability_approximate.tna"
        },

        symbolic_entropy_exact =
        { @key = ENTR_E_KEY,
          @type = @boolean,
          @default = false
        },

        symb_entr_e_file =
        { @key = SYMB_ENTR_E_FILE_NAME_KEY,
          @type = @string,
          @default = "symbolic_entropy_exact.tna"
        },

        symbolic_probability_exact =
        { @key = PROB_E_KEY,
          @type = @boolean,
          @default = false
        },

        symb_prob_e_file =
        { @key = SYMB_PROB_E_FILE_NAME_KEY,
          @type = @string,
          @default = "symbolic_probability_exact.tna"
        },

        symbolic_sequence =
        { @key = SYMBOLIC_SEQUENCE_KEY,
          @type = @boolean,
          @default = true
        },

        symbolic_sequence_file =
        { @key = SYMB_SEQ_FILE_NAME_KEY,
          @type = @string,
          @default = "symbolic_sequence.tna"
        },

        periodic_symbolic_sequence =
        { @key = PERIODIC_SYMBOLIC_SEQUENCE_KEY,
          @type = @boolean,
          @default = false
        },

        periodic_symbolic_sequence_file =
        { @key = PERIODIC_SYMB_SEQ_FILE_NAME_KEY,
          @type = @string,
          @default = "periodic_symbolic_sequence.tna"
        }
      }
    }, #symbolic_analysis

# -----------------------------------------------
# --- RIM --------------------------------------
#------------------------------------------------

     rim_analysis =
     { @key = SIPA_ANALYSIS_KEY,
       @optional = yes,
       @type = @record,
       @label = "RIM analysis",
       @tooltip = "Analysis based on root finding in set image",
       @record =
       {
         is_active =
         { @key = IS_ACTIVE_KEY,
           @label = "is active",
           @tooltip = "Activate the method",
           @type = @boolean,
           @default = false
         },
 #        characteristic_points =
 #        { @key = CHARACTERISTIC_POINTS_KEY,
 #          @optional = yes,
 #          @label = "Characteristic points",
 #          @tooltip = "Detection of characteristic points in discrete systems",
 #          @type = @record,
 #          @record =
 #          {
          type =
            { @key = TYPE_KEY,
              @type = @enum,
              @enum =
              { periodic_points = PERIODIC_POINTS_DETECTION,
                zero_points = ZERO_POINTS_DETECTION,
                solution_points = SOLUTION_POINTS_DETECTION
              },
              @default = periodic_points
            },

            solution_point =
            { @key = SOLUTION_POINT_KEY,
              @type = @array,
              @depth = 1,
              @label = "solution point",
              @tooltip = "The solution y of the equation f(x) = y.",
              @element = {@type = @real}
            },

            number_of_iterations =
            { @key = NUMBER_OF_ITERATIONS_KEY,
              @default = 1,
              @min = 1,
              @type = @like,
              @like = (investigation_methods, symbolic_image_analysis, covering, number_of_iterations)
            },

			min_zero_distance =
            { @key = MIN_ZERO_DISTANCE_KEY,
              @type = @array,
              @optional = true,
              @label = "min zero distance",
              @tooltip = "Minimal distance to zero.",
              @depth = 2,
              @element = {@type = @real}
            },

			image_epsilon =
            { @key = IMAGE_EPSILON_KEY,
              @type = @real,
              @optional = yes,
			  @min = 0.0,
              @label = "image epsilon",
              @tooltip = "Epsilon (error) for convex hull approximation."
            },

			image_epsilon_modification[] =
            { @key = IMAGE_EPSILON_ARRAY_KEY_MODIFICATION,
              @type = @record,
              @dynamic = yes,
              @optional = yes,
              @label = "Image epsilon for a subdivision (modification)",
              @record =
              { subdivision_step = 
			    { @key = SUBDIVISION_STEP_KEY,
                  @type = @integer,
                  @label = "subdivision step",
                  @tooltip = "Apply modification for specified subdivision step.",
                  @min = 0
                },
			    application_mode =
                { @key = APPLICATION_MODE_KEY,
                  @label = "application mode",
                  @type = @enum,
                  @enum =
                  { only_this_subdvision_step = ONLY_THIS_SUBDIVISION_STEP,
                    all_following_subdivision_steps = ALL_FOLLOWING_SUBDIVISION_STEPS
                  },
                  @default = only_this_subdvision_step
                },
                modified_value = {
                  @key = MODIFIED_VALUE_KEY,
                  @label = "image epsilon",
                  @type = @like,
                  @like = (investigation_methods,
                            rim_analysis,image_epsilon)
                }
			  }
			},

            start_iteration_calc =
            { @key = START_ITER_CALC_KEY,
              @type = @integer,
              @label = "start iteration calculation",
              @tooltip = "Start calculation at the specified function iteration step.",
              @min = 1,
			  @optional = yes
            },


			iteration_calc_step_size = 
			{ @key = CALC_STEP_SIZE_KEY,
			  @type = @integer,
			  @label = "iteration calc step size",
			  @tooltip = "Calculate function only at every k-th iteration step.",
			  @min = 0,
			  @default = 0,
			  @optional = yes
			},

            subdivision_depth =
            { @key = SUBDIVISION_DEPTH_KEY,
              @type = @like,
              @like = (investigation_methods, symbolic_image_analysis, covering, subdivision_depth)
            },

            uniform_grid[] =
            { @key = UNIFORM_GRID,
              @type = @like,
              @like = (investigation_methods, symbolic_image_analysis, covering, uniform_grid[])
            },

            point_select =
           { @key = POINT_SELECT_KEY,
             @type = @record,
             @label = "scan point selection",
             @tooltip = "Selection of scan points.",
             @optional = yes,
             @record =
             { type =
               { @key = TYPE_KEY,
                 @type = @enum,
                 @label = "type",
                 @enum =
                 { border_points = BORDER_POINTS,
		   position = POSITION
                 }
                },
				positions =
                { @key = POSITION_KEY,
                  @type = @array,
                  @depth = 2,
                  @label = "positions",
                  @tooltip = "The local coordinates of the scan points.",
                  @element = {@type = @real, @default = 0.5, @min = 0, @max = 1}
                },
                number_of_positions =
                { @key = NUMBER_OF_POSITIONS_KEY,
                  @type = @integer,
                  @label = "number of positions",
                  @tooltip = "Number of scan points",
                  @min = 1,
                  @default = 1
                },
                error_tolerance =
                { @key = SCAN_ERROR_TOLERANCE_KEY,
                  @type = @real,
                  @label = "scan error tolerance",
                  @tooltip = "Error tolerance parameter for border point definition.",
                  @default = 0.0,
                  @min = 0.0
                }
              }
            },

            interval_select[] =
            { @key = INTERVAL_SELECT,
              @type = @like,
              @like = (investigation_methods, symbolic_image_analysis, covering, interval_select[])
            },

            output_value_approximation =
            { @key = VALUE_POSITION,
              @type = @like,
              @like = (investigation_methods, symbolic_image_analysis, covering, output_format[], value_position)
            },

             calculate_convex_hull =
            { @key = CALCULATE_CONVEX_HULL_KEY,
              @type = @boolean,
              @label = "calculate convex hull",
              @tooltip = "Use convex hull calculation for better approximation",
              @default = true
            },

            include_convex_hull_error_boxes =
            { @key = INCLUDE_CONVEX_HULL_ERROR_KEY,
              @type = @boolean,
              @label = "Include convex hull error boxes",
              @tooltip = "Include boxes for which convex hull calculation produced an error",
              @default = true
            },

            max_value_range =
            { @key = MAX_VALUE_RANGE_KEY,
              @type = @array,
              @label = "max value range",
              @optional = true,
              @tooltip = "Range of the accepted image values.",
              @depth = 2,
              @element = {@type = @real}
            },

            max_cells =
            { @key = MAX_CELLS_KEY,
              @type = @like,
              @like = ( investigation_methods, symbolic_image_analysis, image_cells, max_cells)
            },

            separated_cell_calculation =
            { @key = SEPARATED_CALCULATION_KEY,
              @type = @boolean,
              @default = false,
              @label = "separated cell calculation",
              @tooltip = "Calculate each initial cell separately" 
            }
		   }
		},

#        },
#
#         back_orbit =
#         { @key = BACK_ORBIT_KEY,
#           @optional = yes,
#           @label = "backward orbit",
#           @tooltip = "Detection of backward orbits in discrete systems",
#           @type = @record,
#           @record =
#           {
#
#            start_position =
#            { @key = START_POSITION_KEY,
#              @type = @array,
#              @depth = 1,
#              @label = "orbit start position",
#              @tooltip = "The start position of the backward orbit.",
#              @element = {@type = @real}
#            },
#
#            number_of_back_iterations =
#            { @key = BACK_ITERATION_KEY,
#              @type = @integer,
#              @label = "Back iterations",
#              @tooltip = "Number of backward steps",
#              @min = 1,
#              @default = 1
#            },
#
#           number_of_subdivide_edges =
#            { @key = NUMBER_OF_SUBDIVIDE_EDGES,
#              @type = @integer,
#              @label = "subdivide edges",
#              @tooltip = "Number of edges for subdivision",
#              @min = 1,
#              @default = 1
#            },
#
#            subdivision_depth =
#            { @key = SUBDIVISION_DEPTH_KEY,
#              @type = @like,
#              @like = (investigation_methods, symbolic_image_analysis, covering, subdivision_depth)
#            },
#
#            number_of_iterations =
#            { @key = NUMBER_OF_ITERATIONS_KEY,
#              @type = @like,
#              @default = 1,
#              @min = 1,
#              @like = (investigation_methods, symbolic_image_analysis, covering, number_of_iterations)
#            },
#
#            uniform_grid[] =
#            { @key = UNIFORM_GRID,
#              @type = @like,
#              @like = (investigation_methods, symbolic_image_analysis, covering, uniform_grid[])
#            },
#
#            point_select =
#            { @key = POINT_SELECT_KEY,
#              @type = @like,
#              @like = (investigation_methods, symbolic_image_analysis, covering, point_select)
#            },
#
#            interval_select[] =
#            { @key = INTERVAL_SELECT,
#              @type = @like,
#              @like = (investigation_methods, symbolic_image_analysis, covering, interval_select[])
#            },
#
#            max_error_dist =
#            { @key = MAX_ERROR_DIST_KEY,
#              @type = @real,
#             @label = "max error distance",
#              @tooltip = "The maximum distance of the calculated point to the real point"
#            },
#           
#            output_value_approximation =
#           { @key = VALUE_POSITION,
#              @type = @like,
#              @like = (investigation_methods, symbolic_image_analysis, covering, output_format[], value_position)
#            },
#
#            construct_symbolic_image =
#            { @key = CONSTRUCT_SYMIM_KEY,
#              @type = @boolean,
#              @default = true,
#              @label = "construct symbolic image",
#              @tooltip = "Constructs a symbolic image for the initial cells"
#            },
#
#            max_cells =
#            { @key = MAX_CELLS_KEY,
#              @type = @like,
#              @like = ( investigation_methods, symbolic_image_analysis, image_cells, max_cells)
#            }
#           }
#         }
#         
#       }
#     },

# -----------------------------------------------
# --- Symbolic Images ---------------------------
# -----------------------------------------------

    symbolic_image_analysis =
    { @key = SYMBOLIC_IMAGE_ANALYSIS_KEY,
      @optional = yes,
      @type = @record,
      @label = "symbolic image analysis",
      @tooltip = "Construction and analysis of symbolic images. Method can be used for maps or ODEs",
      @record =
      { is_active =
        { @key = IS_ACTIVE_KEY,
          @label = "is active",
          @tooltip = "Activate the method",  
          @type = @boolean,
          @default = false
         },

#------- Covering ------------

        covering =
        { @key =  COVERING_KEY,
          @type = @record,
          @label = "covering",
          @tooltip = "Definition of a covering for the construction of the symbolic image.",
          @record =
          { type =
            { @key = TYPE_KEY,
              @type = @enum,
              @enum =
              { uniform_grid_box = UNIFORM_GRID_BOX
              },
              @default = uniform_grid_box
            },

            subdivision_depth =
            { @key = SUBDIVISION_DEPTH_KEY,
              @type = @integer,
              @label = "subdivision depth",
              @tooltip = "Number of subdivisions n.",
              @default = 6,
              @min = 0
            },

            number_of_iterations =
            { @key = NUMBER_OF_ITERATIONS_KEY,
              @type = @integer,
              @label = "number of iterations",
              @tooltip = "Number of iterations n to get y = f^n(x).",
              @default = 1,
              @min = 1
            },

            number_of_iterations_modification[] =
            { @key = NUMBER_OF_ITERATIONS_ARRAY_KEY_MODIFICATION,
              @type = @record,
              @dynamic = yes,
              @optional = yes,
              @label = "number of iterations for a subdivision (modification)",
              @record =
              { subdivision_step = {
                 @key = SUBDIVISION_STEP_KEY,
                 @type = @integer,
                 @label = "subdivision step",
                 @tooltip = "Apply modification for specified subdivision step.",
                 @min = 0
                },
                application_mode = 
                { @key = APPLICATION_MODE_KEY,
                  @label = "application mode",
                  @type = @enum,
                  @enum =
                  { only_this_subdvision_step = ONLY_THIS_SUBDIVISION_STEP,
                    all_following_subdivision_steps = ALL_FOLLOWING_SUBDIVISION_STEPS
                  },
                  @default = only_this_subdvision_step
                },
                modified_value = {
                 @key = MODIFIED_VALUE_KEY,
                 @type = @integer,
                 @label = "number of iterations",
                 @min = 1
                }
              }
            },

             stop_iter_in_new_box_modification[] =
            { @key = STOP_ITER_IN_NEW_BOX_ARRAY_MODIFICATION,
              @type = @record,
              @dynamic = yes,
              @optional = yes,
              @label = "stop iteration in a new box for a subdivision (modification)",
              @record =
              { subdivision_step = {
                 @key = SUBDIVISION_STEP_KEY,
                 @type = @integer,
                 @label = "subdivision step",
                 @tooltip = "Apply modification for specified subdivision step.",
                 @min = 0
                },
                application_mode =
                { @key = APPLICATION_MODE_KEY,
                  @label = "application mode",
                  @type = @enum,
                  @enum =
                  { only_this_subdvision_step = ONLY_THIS_SUBDIVISION_STEP,
                    all_following_subdivision_steps = ALL_FOLLOWING_SUBDIVISION_STEPS
                  },
                  @default = only_this_subdvision_step
                },
                modified_value = {
                 @key = MODIFIED_VALUE_KEY,
                 @type = @boolean,
                 @label = "The iteration of f^n(x) will be stopped if a new box is reached.",
                 @default = true
                }
              }
            },

            connect_iter_boxes =
            { @key = CONNECT_ITER_BOXES,
              @type = @boolean,
              @label = "connect iterated boxes",
              @tooltip = "Set edges between the boxes visited through calculating of f^n(x).",
              @default = false
            },

            connect_iter_boxes_modification[] =
            { @key = CONNECT_ITER_BOXES_ARRAY_MODIFICATION,
              @type = @record,
              @dynamic = yes,
              @optional = yes,
              @label = "connect iterated boxes for a subdivision (modification)",
              @record =
              { subdivision_step = {
                 @key = SUBDIVISION_STEP_KEY,
                 @type = @integer,
                 @label = "subdivision step",
                 @tooltip = "Apply modification for specified subdivision step.",
                 @min = 0
                },
                application_mode =
                { @key = APPLICATION_MODE_KEY,
                  @label = "application mode",
                  @type = @enum,
                  @enum =
                  { only_this_subdvision_step = ONLY_THIS_SUBDIVISION_STEP,
                    all_following_subdivision_steps = ALL_FOLLOWING_SUBDIVISION_STEPS
                  },
                  @default = only_this_subdvision_step
                },
                modified_value = {
                 @key = MODIFIED_VALUE_KEY,
                 @type = @boolean,
                 @label = "Set edges between the boxes visited through calculating of f^n(x).",
                 @default = true
                }
              }
            },

            load_domain_description =
            { @key = LOAD_DOMAIN_DESCRIPTION,
              @type = @string,
              @label = "Load domain description",
              @tooltip = "Loads data points from a file so that in a first subdivision step all boxes get subdivided whose covered area contains one or more of the data points."
            },
            
            uniform_grid[] =
            { @key = UNIFORM_GRID,
              @label = "Uniform grid definition",
              @tooltip = "Definition of an axis of a uniform grid box covering.",
              @type = @record,
              @record =
              { range =
                { @key = RANGE_KEY,
                  @type = @array,
                  @depth = 1,
                  @label ="range",
                  @tooltip = "The min and max value of the grid box range.",
                  @element = {@type = @real},
                  @default = (0,1)
                },
                initial_cells =
                { @key = INITIAL_CELLS_KEY,
                  @type = @integer,
                  @label = "initial cells",
                  @tooltip = "Initial division of the covering into cells.",
                  @min = 1,
                  @default=1
                },
                subdivide_in =
                { @key = SUBDIVIDE_IN_KEY,
                  @type = @integer,
                  @label = "subdivide in",
                  @tooltip = "Subdivision of a cell into new cells for a subdivision step.",
                  @min = 1
                },
                subdivide_in_modification[] =
                { @key = SUBDIVIDE_IN_ARRAY_KEY_MODIFICATION,
                  @type = @record,
                  @dynamic = yes,
                  @optional = yes,
                  @label = "subdivide in for a subdivision (modification)",
                  @record =
                  { subdivision_step = {
                     @key = SUBDIVISION_STEP_KEY,
                     @type = @integer,
                     @label = "subdivision step",
                     @tooltip = "Apply modification for specified subdivision step.",
                     @min = 0
                  },
                  application_mode =
                  { @key = APPLICATION_MODE_KEY,
                    @label = "application mode",
                    @type = @enum,
                    @enum =
                    { only_this_subdvision_step = ONLY_THIS_SUBDIVISION_STEP,
                      all_following_subdivision_steps = ALL_FOLLOWING_SUBDIVISION_STEPS
                    },
                    @default = only_this_subdvision_step
                  },
                  modified_value = {
                   @key = MODIFIED_VALUE_KEY,
                   @type = @integer,
                   @label = "number of subdivisions",
                   @min = 1
                  }
                 }
                },
                error_tolerance =
                { @key = ERROR_TOLERANCE_KEY,
                  @label = "error tolerance",
                  @tooltip = "Error tolerance for the calculation of the covering.",
                  @type = @real,
                  @min = 0
                },
                error_tolerance_modification[] =
                { @key = ERROR_TOLERANCE_ARRAY_KEY_MODIFICATION,
                  @type = @record,
                  @dynamic = yes,
                  @optional = yes,
                  @label = "error tolerance for a subdivision (modification)",
                  @record =
                  { subdivision_step = {
                     @key = SUBDIVISION_STEP_KEY,
                     @type = @integer,
                     @label = "subdivision step",
                     @tooltip = "Apply modification for specified subdivision step.",
                     @min = 0
                  },
                  application_mode =
                  { @key = APPLICATION_MODE_KEY,
                    @label = "application mode",
                    @type = @enum,
                    @enum =
                    { only_this_subdvision_step = ONLY_THIS_SUBDIVISION_STEP,
                      all_following_subdivision_steps = ALL_FOLLOWING_SUBDIVISION_STEPS
                    },
                    @default = only_this_subdvision_step
                  },
                  modified_value = {
                   @key = MODIFIED_VALUE_KEY,
                   @label = "error tolerance",
                   @type = @like,
                   @like = (investigation_methods,
                            symbolic_image_analysis,covering,uniform_grid[],error_tolerance)
                  }
                 }
                }
              }
           },
           point_select =
           { @key = POINT_SELECT_KEY,
             @type = @record,
             @label = "scan point selection",
             @tooltip = "Selection of scan points.",
             @optional = yes,
             @record =
             { type =
               { @key = TYPE_KEY,
                 @type = @enum,
                 @label = "type",
                 @enum =
                 { position = POSITION,
                   border_points = BORDER_POINTS
                 }
                },
                number_of_positions =
                { @key = NUMBER_OF_POSITIONS_KEY,
                  @type = @integer,
                  @label = "number of positions",
                  @tooltip = "Number of scan points",
                  @min = 1,
                  @default = 1
                },
                positions =
                { @key = POSITION_KEY,
                  @type = @array,
                  @depth = 2,
                  @label = "positions",
                  @tooltip = "The local coordinates of the scan points.",
                  @element = {@type = @real, @default = 0.5, @min = 0, @max = 1}
                },
                error_tolerance =
                { @key = SCAN_ERROR_TOLERANCE_KEY,
                  @type = @real,
                  @label = "scan error tolerance",
                  @tooltip = "Error tolerance parameter for border point definition.",
                  @default = 0.0,
                  @min = 0.0
                }
              }
            },
            interval_select[] =
            { @key = INTERVAL_SELECT,
              @type = @record,
              @label = "interval select",
              @tooltip = "Selection of scan points in an interval.",
              @optional = yes,
              @dynamic = yes,
              @record =
              { type =
                { @key = TYPE_KEY,
                  @type = @enum,
                  @label = "type",
                  @enum =
                  { interval = INTERVAL },
                  @default = interval
                },
                interval_range[] =
                { @key = INTERVAL_RANGE,
                  @label = "interval range",
                  @optional = no,
                  @type = @record,
                  @record =
                  { range =
                    { @key = RANGE_KEY,
                      @type = @array,
                      @label = "range",
                      @tooltip = "Range of the interval in local coordinates.",
                      @depth = 1,
                      @element = {@type = @real, @min = 0, @max = 1},
                      @default = (0,1)
                    },
                    number_of_positions =
                    { @key = NUMBER_OF_POSITIONS_KEY,
                      @type = @integer,
                      @label = "number of positions",
                      @tooltip = "Number of scan positions in the interval.",
                      @min = 1
                    },
                    selection =
                    { @key = SELECTION_KEY,
                      @type = @enum,
                      @label = "selection type",
                      @tooltip = "Type of selection of the scan positions on the interval.",
                      @enum =
                      { equidistant  = EQUIDISTANT,
                        random = RANDOM
                      },
                      @default = equidistant
                    }
                  }
                }
              }
            },           
             
#--------- Linear extension --------------

            linear_extension =
            { @key = LINEAR_EXTENSION_KEY,
              @type = @record,
              @label = "linear extension",
              @tooltip = "Construction of the linear extension needed for calculation of the Morse Spectrum.",
              @optional = yes,
              @record =
              {
                is_active =
                { @key = IS_ACTIVE_KEY,
                  @label = "is active",	
                  @tooltip = "Activate the method",  
                  @type = @boolean,
                  @default = false
                },
                type =
                { @key = TYPE_KEY,
                  @type = @enum,
                  @label = "type",
                  @enum =
                  { equidistant = EQUIDISTANT },
                  @default = equidistant
                },
                number_of_positions =
                { @key = NUMBER_OF_POSITIONS_KEY,
                  @type = @integer,
                  @label = "Number of positions",
                  @tooltip = "Number of initial positions (subdivisions) of the extension vector.",
                  @default = 1,
                  @min = 1
                },
                start_at_subdivision =
                { @key = START_AT_SUBDIVISION,
                  @type = @integer,
                  @label = "start at subdivision",
                  @tooltip = "Subdvision step at which the linear extension will be activated.",
                  @default = 0,
                  @min = 0
                },
                subdivide_in =
                { @key = SUBDIVIDE_IN_KEY,
                  @type = @integer,
                  @label = "subdivide in",
                  @tooltip = "Subdivision of an area.",
                  @default = 1,
                  @min = 1
                 },
                 subdivide_in_modification[] =
                { @key = SUBDIVIDE_IN_ARRAY_KEY_MODIFICATION,
                  @type = @record,
                  @dynamic = yes,
                  @optional = yes,
                  @label = "subdivide in for a subdivision (modification)",
                  @record =
                  { subdivision_step = {
                     @key = SUBDIVISION_STEP_KEY,
                     @type = @integer,
                     @label = "subdivision step",
                     @tooltip = "Apply modification for specified subdivision step.",
                     @min = 0
                  },
                  application_mode =
                  { @key = APPLICATION_MODE_KEY,
                    @label = "application mode",
                    @type = @enum,
                    @enum =
                    { only_this_subdvision_step = ONLY_THIS_SUBDIVISION_STEP,
                      all_following_subdivision_steps = ALL_FOLLOWING_SUBDIVISION_STEPS
                    },
                    @default = only_this_subdvision_step
                  },
                  modified_value = {
                   @key = MODIFIED_VALUE_KEY,
                   @type = @integer,
                   @label = "subdivision of an area",
                   @min = 1
                  }
                 }
                },
                number_of_scans =
                { @key = NUMBER_OF_SCANS_KEY,
                  @type= @integer,
                  @label = "number of scans",
                  @tooltip = "Number of scans for each area covered by a vector.",
                  @default = 1,
                  @min = 0
                },
                number_of_scans_modification[] =
                { @key = NUMBER_OF_SCANS_ARRAY_KEY_MODIFICATION,
                  @type = @record,
                  @dynamic = yes,
                  @optional = yes,
                  @label = "number of scans for a subdivision (modification)",
                  @record =
                  { subdivision_step = {
                     @key = SUBDIVISION_STEP_KEY,
                     @type = @integer,
                     @label = "subdivision step",
                     @tooltip = "Apply modification for specified subdivision step.",
                     @min = 0
                  },
                  application_mode =
                  { @key = APPLICATION_MODE_KEY,
                    @label = "application mode",
                    @type = @enum,
                    @enum =
                    { only_this_subdvision_step = ONLY_THIS_SUBDIVISION_STEP,
                      all_following_subdivision_steps = ALL_FOLLOWING_SUBDIVISION_STEPS
                    },
                    @default = only_this_subdvision_step
                  },
                  modified_value = {
                   @key = MODIFIED_VALUE_KEY,
                   @type = @integer,
                   @label = "Number of scans for each area covered by a vector.",
                   @min = 1
                  }
                 }
                }
              }
            },

#---------- Output format ---------------

            output_format[] =
            { @key = OUTPUT_FORMAT,
              @type = @record,
              @label = "output format",
              @tooltip = "Definition of the output format of cell and set data.",
              @dynamic = yes,
              @record =
              { type =
                { @key = TYPE_KEY,
                  @label = "type",
                  @type = @enum,
                  @enum =
                  { box_output = BOX_OUTPUT,
                    range_output = RANGE_OUTPUT
                  },
                  @default = box_output
                },
                box_indices =
                { @key = BOX_INDICES,
                  @type = @boolean,
                  @label = "box indices",
                  @tooltip = "Output of the box indices.",
                  @default = no
                },
                box_values =
                { @key = BOX_VALUES,
                  @type = @boolean,
                  @label = "box values",
                  @tooltip = "Output of the position of a box in the domain space.",
                  @default = yes
                },
                value_position =
                { @key = VALUE_POSITION,
                  @type = @array,
                  @label = "value position",
                  @tooltip = "Local coordinates for the position of the output value of a box-",
                  @depth = 1,
                  @element = {@type = @real, @default = 0.5, @min = 0, @max = 1},
                  @optional = yes
                },
                range_indices =
                { @key = RANGE_INDICES,
                  @type = @boolean,
                  @label = "range indices",
                  @tooltip = "Output of the set indices.",
                  @default = no
                },
                range_values =
                { @key = RANGE_VALUES,
                  @type = @boolean,
                  @label = "range values",
                  @tooltip = "Output of the set range in the domain space.",
                  @default = yes
                }
              }
             }
          }
        },

#--------Image cells ------------------------

        image_cells =
        { @key = IMAGE_CELLS_KEY,
          @type = @record,
          @label = "image cells",
          @tooltip = "Parameters and analysis of a smybolic image",
          @record =
          { type =
            { @key = TYPE_KEY,
              @type = @enum,
              @label = "type",
              @enum =
              { default = DEFAULT
#-------        morse_spectrum = MORSE_SPECTRUM
              },
              @default = default
            },
            max_cells =
            { @key = MAX_CELLS_KEY,
              @type = @integer,
              @label = "maximum number of cells",
              @tooltip =  "Allowed maximum number of cells.",
              @min = 1,
              @default = 1000000
            },
            period_finder =
            { @key = PERIOD_FINDER_KEY,
              @type = @enum,
              @label = "period finder type",
              @tooltip = "Algorithm used for calculation of recurrent cells.",
              @enum =
              { connected_components = CONNECTED_COMPONENTS,
                shortest_path = SHORTEST_PATH,
                data_file = DATA_FILE
              },
              @default = connected_components
            },
            period_finder_modification[] =
            { @key = PERIOD_FINDER_ARRAY_KEY_MODIFICATION,
              @type = @record,
              @dynamic = yes,
              @optional = yes,
              @label = "period finder type for a subdivision (modification)",
              @record =
              { subdivision_step = {
                 @key = SUBDIVISION_STEP_KEY,
                 @type = @integer,
                 @label = "subdivision step",
                 @tooltip = "Apply modification for specified subdivision step.",
                 @min = 0
                },
                application_mode =
                { @key = APPLICATION_MODE_KEY,
                  @label = "application mode",
                  @type = @enum,
                  @enum =
                  { only_this_subdvision_step = ONLY_THIS_SUBDIVISION_STEP,
                    all_following_subdivision_steps = ALL_FOLLOWING_SUBDIVISION_STEPS
                  },
                  @default = only_this_subdvision_step
                },
                modified_value = {
                  @key = MODIFIED_VALUE_KEY,
                  @type = @enum,
                  @label = "Algorithm used for calculation of recurrent cells.",
                  @enum =
                  { connected_components = CONNECTED_COMPONENTS,
                    shortest_path = SHORTEST_PATH,
                    data_file = DATA_FILE 
                  },
                  @default = connected_components
                }
              }
            },
            load_recurrent_set_description[] =
            { @key = LOAD_RECURRENT_SET_DESCRIPTION_KEY,
              @type = @record,
              @dynamic = yes,
              @optional = yes,
              @label = "Load recurrent set description",
              @tooltip = "Loads data points from a file so that all cells are marked as recurrent in which one of the points lie.",
              @record =
              { file =
                { @key = FILENAME_KEY,
                  @label = "file",
                  @tooltip = "Path to data file.",
                  @optional = no,
                  @type = @string
                },
                start_row =
                { @key = START_ROW_KEY,
                  @type = @integer,
                  @label = "start row",
                  @tooltip = "Start row for value parsing.",
                  @default = 1
               },
               start_line =
               { @key = START_LINE_KEY,
                  @type = @integer,
                  @label = "start line",
                  @tooltip = "Start line for value parsing.",
                  @default = 1
               },
               error_tolerance =
               { @key = ERROR_TOLERANCE_KEY,
                  @label = "error tolerance",
                  @tooltip = "Error tolerance for the selection of the cells.",
                  @type = @real,
                  @min = 0
                }
              }
            }, 
            
            max_periods =
            { @key = MAX_PERIODS_KEY,
              @type = @integer,
              @label = "max periods",
              @tooltip = "Only mark cells with a period lower or equal the number defined here.",
              @min = 0,
			  @default = 0
            },
            max_periods_modification[] =
            { @key = MAX_PERIODS_ARRAY_KEY_MODIFICATION,
              @type = @record,
              @dynamic = yes,
              @optional = yes,
              @label = "max periods for a subdivision (modification)",
              @record =
              { subdivision_step = {
                 @key = SUBDIVISION_STEP_KEY,
                 @type = @integer,
                 @label = "subdivision step",
                 @tooltip = "Apply modification for specified subdivision step.",
                 @min = 0
                },
                application_mode =
                { @key = APPLICATION_MODE_KEY,
                  @label = "application mode",
                  @type = @enum,
                  @enum =
                  { only_this_subdvision_step = ONLY_THIS_SUBDIVISION_STEP,
                    all_following_subdivision_steps = ALL_FOLLOWING_SUBDIVISION_STEPS
                  },
                  @default = only_this_subdvision_step
                },
                modified_value = {
                  @key = MODIFIED_VALUE_KEY,
                  @type = @integer,
                  @label = "Only mark cells with a period lower or equal the number defined here.",
                   @min = 1
                }
              }
            },
            order_sets =
            { @key = ORDER_SETS_KEY,
              @type = @boolean,
              @label = "order sets",
              @tooltip = "Calculate the order of the sets.",
              @default = no
            },
            order_sets_modification[] =
            { @key = ORDER_SETS_ARRAY_KEY_MODIFICATION,
              @type = @record,
              @dynamic = yes,
              @optional = yes,
              @label = "order sets for a subdivision (modification)",
              @record =
              { subdivision_step = {
                 @key = SUBDIVISION_STEP_KEY,
                 @type = @integer,
                 @label = "subdivision step",
                 @tooltip = "Apply modification for specified subdivision step.",
                 @min = 0
                },
                application_mode =
                { @key = APPLICATION_MODE_KEY,
                  @label = "application mode",
                  @type = @enum,
                  @enum =
                  { only_this_subdvision_step = ONLY_THIS_SUBDIVISION_STEP,
                    all_following_subdivision_steps = ALL_FOLLOWING_SUBDIVISION_STEPS
                  },
                  @default = only_this_subdvision_step
                },
                modified_value = {
                  @key = MODIFIED_VALUE_KEY,
                  @type = @boolean,
                  @label = "Calculate the order of the sets.",
                  @default = true
                }
              }
            },
            include_cells_on_trajectory =
            { @key = INCLUDE_CELLS_ON_TRAJECTORY,
              @type = @boolean,
              @label = "include cells on trajectory",
              @tooltip = "Include all the cells between recurrent cells which are visited by applying f^k(x).",
              @default = no
            },
            include_cells_on_trajectory_modification[] =
            { @key = INCLUDE_CELLS_ON_TRAJECTORY_ARRAY_MODIFICATION,
              @type = @record,
              @dynamic = yes,
              @optional = yes,
              @label = "include cells on trajectory for a subdivision (modification)",
              @record =
              { subdivision_step = {
                 @key = SUBDIVISION_STEP_KEY,
                 @type = @integer,
                 @label = "subdivision step",
                 @tooltip = "Apply modification for specified subdivision step.",
                 @min = 0
                },
                application_mode =
                { @key = APPLICATION_MODE_KEY,
                  @label = "application mode",
                  @type = @enum,
                  @enum =
                  { only_this_subdvision_step = ONLY_THIS_SUBDIVISION_STEP,
                    all_following_subdivision_steps = ALL_FOLLOWING_SUBDIVISION_STEPS
                  },
                  @default = only_this_subdvision_step
                },
                modified_value = {
                  @key = MODIFIED_VALUE_KEY,
                  @type = @boolean,
                  @label = "Include all the cells between recurrent cells which are visited by applying f^k(x).",
                  @default = true
                }
              }
            },
            
#---------- Subdivision step --------------

            recurrent_set_selection[] =
            { @key = RECURRENT_SET_SELECTION_ARRAY_KEY,
              @type = @record,
              @dynamic = yes,
              @label = "recurrent set selection",
              @tooltip = "Parameters of a subdivision step.",
              @record =
              { subdivision_step = {
                 @key = SUBDIVISION_STEP_KEY,
                 @type = @integer,
                 @label = "subdivision step",
                 @tooltip = "Apply selection for specified subdivision step.",
                 @min = 0
                },
				application_mode =
                { @key = APPLICATION_MODE_KEY,
                  @label = "application mode",
                  @type = @enum,
                  @enum =
                  { only_this_subdvision_step = ONLY_THIS_SUBDIVISION_STEP,
                    all_following_subdivision_steps = ALL_FOLLOWING_SUBDIVISION_STEPS
                  },
                  @default = only_this_subdvision_step
                },
                select_recurrent_sets[] =
                { @key = RECURRENT_SETS,
                  @type = @record,
                  @label = "select recurrent cell set",
                  @tooltip = "Selection of a set of recurrent cells.",
                  @dynamic = yes,
                  @record =
                  { range =
                    { @key = RANGE_KEY,
                      @type= @array,
                      @label = "range",
                      @tooltip = "Range on an dimension axis for which all recurrent cell sets are included.",
                      @depth = 2,
                      @element = {@type = @real}
                    },
                    set_numbers =
                    { @key = SET_NUMBERS_KEY,
                      @type = @array,
                      @dynamic = yes,
                      @optional = yes,
                      @label = "set numbers",
                      @tooltip = "Selection of recurrent cell sets by their index number.",
                      @depth = 1,
                      @element = {@type = @integer, @min = 0}
                    },
                    only_no_exit =
                    { @key = ONLY_NO_EXIT,
                      @type = @boolean,
                      @label = "only no exit",
                      @tooltip = "Select only recurrent cell sets with no exit edge.",
                      @default = no
                    },
                    mark_domain_of_attraction =
                    { @key = MARK_DOMAIN_OF_ATTRACTION,
                      @type = @boolean,
                      @label = "mark domain of attraction",
                      @tooltip = "Mark the cells belonging to the domain of attraction for this selection.",
                      @default = no
                    },
                    mark_inverse_domain_of_attraction =
                    { @key = MARK_INVERSE_DOMAIN_OF_ATTRACTION,
                      @type = @boolean,
                      @label = "mark inverse domain of attraction",
                      @tooltip = "Mark the cells belonging to the inverse domain of attraction for this selection.",
                      @default = no
                    },
                    connect_with =
                    { @key = CONNECT_WITH,
                      @type = @array,
                      @depth = 1,
                      @label = "connect with",
                      @dynamic = yes,
                      @optional = yes,
                      @tooltip = "Mark the cells connecting this selection with other selections.",
                      @element = {@type = @integer, @min = 0}
                    },
                    lower_bound =
                    { @key = LOWER_BOUND,
                      @type = @boolean,
                      @label = "lower bound",
                      @tooltip = "Detect the lower bound of the domain of attraction and/or the connecting cells.",
                      @default = no
                    }
                  }
                }
              }
            },

#--------- Output writer ---------------

            output_writer[] =
            { @key = OUTPUT_WRITER,
              @type = @record,
              @dynamic = yes,
              @optional = no,
              @label = "output writer",
              @tooltip = "Defintion  of writer objects for symbolic image data",
              @record =
              { type =
                { @key = TYPE_KEY,
                  @type = @enum,
                  @label = "type",
                  @tooltip = "Several output writers exist and can be combined",
                  @enum =
                  { periodic_cell_writer = PERIODIC_CELL_WRITER,
                    all_cell_writer = ALL_CELL_WRITER,
                    selected_sets_cell_writer = SELECTED_SETS_CELL_WRITER,
                    attraction_domain_cell_writer = ATTRACTION_DOMAIN_CELL_WRITER,
                    inverse_attraction_domain_cell_writer = INVERSE_ATTRACTION_DOMAIN_CELL_WRITER,
                    cells_on_trajectory_writer = CELLS_ON_TRAJECTORY_WRITER,
                    period_writer = PERIOD_WRITER,
                    set_order_writer = SET_ORDER_WRITER
#-------            morse_spectrum_writer = MORSE_SPECTRUM_WRITER
                 },
                 @default = periodic_cell_writer
                },
                filename =
                { @key = FILENAME,
                  @type = @string,
                  @label = "filename",
                  @tooltip = "Name of the output file."
                },
                extension =
                { @key = FILE_EXTENSION,
                  @type = @string,
                  @label = "file extension",
                  @tooltip = "Extension added to the filename.",
                  @default = "tna"
                },
                every_subdivision =
                { @key = EVERY_SUBDIVISION,
                  @type = @boolean,
                  @label = "every subdivision",
                  @tooltip = "Write output for every subdivision.",
                  @default = yes
                },
				 box_output =
                { @key = BOX_OUTPUT,
                  @type = @integer,
                  @label = "box output",
                  @tooltip = "Index of the box format object.",
                  @min = 0
                },
				range_output =
                { @key = RANGE_OUTPUT,
                  @type = @integer,
                  @label = "range output",
                  @tooltip = "Index of the set format object.",
                  @min = 0
                },
                periodic_paths =
                { @key = PERIODIC_PATHS,
                  @type = @boolean,
                  @label = "periodic paths",
                  @tooltip = "Ouput successor of a periodic path.",
                  @default = no
                },
                only_subdivisions =
                { @key = ONLY_SUBDIVISIONS,
                  @type = @array,
                  @label = "only subdivisions",
                  @tooltip = "Write output only for the specified subdivision steps.",
                  @depth = 1,
                  @element = {@type = @integer, @min = 0},
                  @dynamic = yes,
                  @optional = yes
                },
                invariant_set =
                { @key = INVARIANT_SET,
                  @type = @boolean,
                  @label = "invariant set",
                  @tooltip = "Output index of the recurrent cell set if cell is recurrent.",
                  @default = no
                },
                period_size =
                { @key = PERIOD_SIZE,
                  @type = @boolean,
                  @label = "period size",
                  @tooltip = "Outputs size of the period of a cell if computed.",
                  @default = no
                },
                cell_edges =
                { @key = CELL_EDGES,
                  @type = @boolean,
                  @label = "cell edges",
                  @tooltip = "Outputs the target cells.",
                  @default = no
                },
                only_periods =
                { @key = ONLY_PERIODS,
                  @type = @array,
                  @label = "only periods",
                  @tooltip = "Write only cells which has one of the specified periods.",
                  @depth = 1,
                  @element = {@type = @integer, @min = 1},
                  @dynamic = yes,
                  @optional = yes
                },
                all_larger_sets =
                { @key = ALL_LARGER_SETS,
                  @type = @boolean,
                  @label = "all larger sets",
                  @tooltip = "Output all larger sets.",
                  @default = no
                },
                set_edges =
                { @key = SET_EDGES,
                  @type = @boolean,
                  @label = "set edges",
                  @default = no
                },
                number_of_cells =
                { @key = NUMBER_OF_CELLS,
                  @type = @boolean,
                  @label = "number of cells",
                  @tooltip = "Output the number of cells belonging to this set.",
                  @default = no
                },
                only_more_cells_than =
                { @key = ONLY_MORE_CELLS_THAN,
                  @type =  @integer,
                  @label = "only more cells than",
                  @tooltip = "Write only sets with more cells than specified.",
                  @min = 0
                },
                max_values =
                { @key = MORSE_MAX_VALUES,
                  @type = @boolean,
                  @label = "morse max values",
                  @tooltip = "The max values of the Morse spectra.",
                  @default = no
                },
                min_values =
                { @key = MORSE_MIN_VALUES,
                  @type = @boolean,
                  @label = "morse min values",
                  @tooltip = "The min values of the Morse spectra.",
                  @default = no
                },
                interpolated_values =
                { @key = MORSE_INTERPOLATED,
                  @type = @boolean,
                  @label = "morse interpolated",
                  @tooltip = "Interpolations of the min and max values of the Morse spetra.",
                  @default = no
                }
              }
            }
          }
        }
      }
    }, #symbolic_image_analysis

# -----------------------------------------------
# --- Lyapunov Exponents ------------------------
# -----------------------------------------------


    lyapunov_exponents_analysis =
    { @key = LYAPUNOV_EXPONENTS_KEY,
      @optional = yes,
      @type = @record,
      @record =
      { is_active =
        { @key = IS_ACTIVE_KEY,
	  @label = "is active",	
	  @tooltip = "Activate the method",  
          @type = @boolean,
          @default = false
        },

        integration =
        { @key = INTEGRATION_METHOD_KEY,
          @optional = yes,
          @type = @like,
          @like = (dynamical_system, integration)
        },

        use_linearized_system =
        { @key = LINEARIZED_KEY,
          @type = @boolean,
          @default = false
        },

        epsilon =
        { @key = EPSILON_KEY,
          @type = @real,
          @default = 1.0e-7
        },

        initial_deviations =
        { @key = INITIAL_DEVIATIONS_KEY,
          @type = @enum,
          @enum =
          { random_vectors = RANDOM_VECTORS_KEY,
            basis_vectors = BASIS_VECTORS_KEY
          },
          @default = random_vectors
        },

        transient =
        { @key = TRANSIENT_KEY,
          @type = @integer,
          @default = 0,
          @min = 0
        },

        number_of_exponents =
        { @key = NUMBER_OF_EXPONENTS_KEY,
          @type = @integer,
          @default = 1,
          @min = 1
        },

        steps_between_reorthonormalization =
        { @key = STEP_KEY,
          @type = @integer,
          @default = 1,
          @min = 1
        },

        using_norm =
        { @key = NORM_KEY,
          @type = @enum,
          @enum =
          { L_max = LMAX_NORM_KEY,
            L2 = L2_NORM_KEY,
            L1 = L1_NORM_KEY,
            Lp = LP_NORM_KEY
          },
          @default = L2
        },

        p =
        { @key = P_OF_LP_NORM_KEY,
          @type = @integer,
          @default = 3,
          @min = 3
        },

        exponents =
        { @key = EXPONENTS_KEY,
          @type = @boolean,
          @default = true
        },

        exponents_file =
        { @key = EXPONENTS_FILE_KEY,
          @type = @string,
          @default = "lyapunov.tna"
        },

        dimension =
        { @key = DIMENSION_KEY,
          @type = @boolean,
          @default = false
        },

        dimension_file =
        { @key = DIMENSION_FILE_KEY,
          @type = @string,
          @default = "lyapunov_dimension.tna"
        },

        status =
        { @key = STATUS_KEY,
          @type = @boolean,
          @default = true
        },

        errors_file =
        { @key = ERRORS_FILE_KEY,
          @type = @string,
          @default = "lyapunov_errors.tna"
        }
      }
    }, #lyapunov_exponents_analysis


# -----------------------------------------------
# --- Regions Analysis --------------------------
# -----------------------------------------------


    regions_analysis =
    { @key = REGIONS_ANALYSIS_KEY,
      @optional = yes,
      @type = @record,
      @record =
      { is_active =
        { @key = IS_ACTIVE_KEY,
	  @label = "is active",	
	  @tooltip = "Activate the method",  
          @type = @boolean,
          @default = false
        },

        period_regions_file =
        { @key = PERIOD_REGIONS_FILE_KEY,
          @type = @string,
          @default = "regions_period.tna"
        },

        period_file =
        { @key = PERIOD_FILE_KEY,
          @type = @string,
          @default = "periods_ij.tmp"
        }
      }
    }, #regions_analysis

# -----------------------------------------------
# --- Dimensions Analysis -----------------------
# -----------------------------------------------


    dimensions_analysis =
    { @key = DIMENSIONS_ANALYSIS_KEY,
      @optional = yes,
      @type = @record,
      @record =
      { is_active =
        { @key = IS_ACTIVE_KEY,
	  @label = "is active",	
	  @tooltip = "Activate the method",  
          @type = @boolean,
          @default = false
        },

        transient =
        { @key = TRANSIENT_KEY,
          @type = @integer,
          @default = 0,
          @min = 0
        },

        median_calculation =
        { @key = MEDIAN_CALCULATION_KEY,
          @type = @enum,
          @tooltip = "Select the method to be used to calculatie the resulting value for the dimensions. Usually there will be a plateau e.g. from layer 4 to layer 8.                                                                  > With the key 'plateau_algorithm', the plateau is found automatically and median is calculated.                                  > When using the key 'user_selected_layers', the median is calculated with the layers selected with 'min_layer' and 'max_layer'. Use the key 'save_all_layers' to check where the plateau is before you use this function.",
          @enum =
          { plateau_algorithm = MEDIAN_PLATEAU_KEY,
            user_selected_layers = MEDIAN_USER_KEY
          }
#        @default = plateau_algorithm
        },

        min_layer =
        { @key = MIN_LAYER_KEY,
          @type = @integer,
          @default = 4,
          @min = 1
        },

        max_layer =
        { @key = MAX_LAYER_KEY,
          @type = @integer,
          @default = 8,
          @min = 4
        },

        partition_factor =
        { @key = PARTITION_FACTOR_KEY,
          @type = @integer,
          @default = 2,
          @min = 2
        },

        automatic_range_detection =
        { @key = AUTO_RANGE_KEY,
          @type = @boolean,
          @default = false
        },

        ranges =
        { @key = RANGES_KEY,
          @type = @array,
          @depth = 2,
          @element = {@type = @real}
        },

        save_outside_points =
        { @key = SAVE_OUTSIDE_POINTS_KEY,
          @type = @boolean,
          @default = false
        },

        outside_points_file =
        { @key = OUTSIDE_POINTS_FILE_KEY,
          @type = @string,
          @default = "outside_points.tna"
        },

        capacity_dimension =
        { @key = CAP_DIMENSION_KEY,
          @type = @boolean,
          @default = false
        },

        cap_dimension_file =
        { @key = CAP_DIMENSION_FILE_KEY,
          @type = @string,
          @default = "capacity_dimension.tna"
        },

        information_dimension =
        { @key = INFO_DIMENSION_KEY,
          @type = @boolean,
          @default = false
        },

        info_dimension_file =
        { @key = INFO_DIMENSION_FILE_KEY,
          @type = @string,
          @default = "information_dimension.tna"
        },

        correlation_dimension =
        { @key = CORR_DIMENSION_KEY,
          @type = @boolean,
          @default = false
        },

        corr_dimension_file =
        { @key = CORR_DIMENSION_FILE_KEY,
          @type = @string,
          @default = "correlation_dimension.tna"
        },

        q_dimension =
        { @key = Q_DIMENSION_KEY,
          @tooltip = "Calculate the q-Dimension (Renyi-Dimension) for some values of q.",
          @type = @boolean,
          @default = false
        },

        q_start =
        { @key = Q_START_KEY,
          @type = @integer,
          @default = 3,
          @min = 2
        },

        q_end =
        { @key = Q_END_KEY,
          @type = @integer,
          @default = 3,
          @min = 2
        },

        q_dimension_file_suffix =
        { @key = Q_DIMENSION_FILE_SUFFIX_KEY,
          @type = @string,
          @default = "q_dimension.tna"
        },

        invariant_measure =
        { @key = INV_MEASURE_KEY,
          @type = @boolean,
          @default = false
        },

        inv_measure_file =
        { @key = INV_MEASURE_FILE_KEY,
          @type = @string,
          @default = "invariant_measure.tna"
        },

        measure_deviation =
        { @key = MEASURE_DEVIATION_KEY,
          @type = @boolean,
          @default = false
        },

        measure_deviation_file =
        { @key = MEASURE_DEVIATION_FILE_KEY,
          @type = @string,
          @default = "measure_deviation.tna"
        },

        metric_entropy =
        { @key = ENTROPY_KEY,
          @type = @boolean,
          @default = false
        },

        entropy_file =
        { @key = ENTROPY_FILE_KEY,
          @type = @string,
          @default = "metric_entropy.tna"
        },

        save_all_layers =
        { @key = SAVE_LAYERS_KEY,
          @type = @boolean,
          @default = false
        }

      }
    }, #dimension_analysis

# -----------------------------------------------
# --- Frequency Analysis ------------------------
# -----------------------------------------------


    frequency_analysis =
    { @key = FREQUENCY_ANALYSIS_KEY,
      @optional = yes,
      @type = @record,
      @record =
      { is_active =
        { @key = IS_ACTIVE_KEY,
	  @label = "is active",	
	  @tooltip = "Activate the method",  
          @type = @boolean,
          @default = false
        },

        subtract_mean_value =
        { @key = ZERO_MEAN_VALUES_KEY,
          @type = @boolean,
          @default = yes
        },

        points_step =
        { @key = POINTS_STEP_KEY,
          @type = @integer,
          @default = 1,
          @min = 1
        },

        transient =
        { @key = TRANSIENT_KEY,
          @type = @integer,
          @default = 0,
          @min = 0
        },

        using_variables =
        { @key = USING_VARIABLES_KEY,
          @type = @array,
          @depth = 1,
          @element = {@type = @integer, @min = 0},
          @dynamic = yes
        },

        frequency_step_is_given =
        { @key = FREQUENCY_STEP_IS_GIVEN_KEY,
          @type = @boolean,
          @default = no
        },

        frequency_step =
        { @key = FREQUENCY_STEP_KEY,
          @type = @real
        },

        number_of_points =
        { @key = NUMBER_OF_POINTS_KEY,
          @type = @integer,
          @default = 1000,
          @min = 1
        },

        file_extension =
        { @key = FILE_EXT_KEY,
          @type = @string,
          @default = "tna"
        },

        real_part =
        { @key = REAL_KEY,
          @type = @boolean,
          @default = false
        },

        re_file =
        { @key = RE_FILE_KEY,
          @type = @string,
          @default = "frequency_real_part"
        },

        imaginary_part =
        { @key = IMAG_KEY,
          @type = @boolean,
          @default = false
        },

        im_file =
        { @key = IM_FILE_KEY,
          @type = @string,
          @default = "frequency_imaginary_part"
        },

        real_and_imaginary_parts =
        { @key = REAL_IMAG_KEY,
          @type = @boolean,
          @default = false
        },

        re_im_file =
        { @key = RE_IM_FILE_KEY,
          @type = @string,
          @default = "real_and_imaginary_parts"
        },

        power_spectrum =
        { @key = POWER_SP_KEY,
          @type = @boolean,
          @default = true
        },

        power_sp_file =
        { @key = POWER_SP_FILE_KEY,
          @type = @string,
          @default = "power_spectrum"
        },

        frequency_output_range =
        { @key = FREQUENCY_OUTPUT_RANGE_KEY,
          @type = @array,
          @depth = 1,
          @element = {@type = @real}
        },

        autocorrelation =
        { @key = AUTO_CORR_KEY,
          @type = @boolean,
          @default = false
        },

        auto_corr_file =
        { @key = AUTO_CORR_FILE_KEY,
          @type = @string,
          @default = "autocorrelation"
        },

        total_power =
        { @key = TOTAL_POWER_KEY,
          @type = @boolean,
          @default = false
        },

        total_power_file =
        { @key = TOTAL_POWER_FILE_KEY,
          @type = @string,
          @default = "total_power.tna"
        },

        spectrum_oscillation =
        { @key = SPECTRUM_OSCILLATION_KEY,
          @type = @boolean,
          @default = false
        },

        spectrum_oscillation_file =
        { @key = SPECTRUM_OSCILLATION_FILE_KEY,
          @type = @string,
          @default = "spectrum_oscillation.tna"
        },

        period =
        { @key = PERIOD_KEY,
          @type = @boolean,
          @default = false
        },

        period_file =
        { @key = PERIOD_FILE_KEY,
          @type = @string,
          @default = "assumed_period.tna"
        },

        spectrum_max_points =
        { @key = SPECTRUM_MAX_POINTS_KEY,
          @type = @boolean,
          @default = false
        },

        spectrum_max_points_file =
        { @key = SPECTRUM_MAX_POINTS_FILE_KEY,
          @type = @string,
          @default = "spectrum_max_points"
        },

        spectrum_waving =
        { @key = SPECTRUM_WAVING_KEY,
          @type = @boolean,
          @default = false
        },

        spectrum_waving_file =
        { @key = SPECTRUM_WAVING_FILE_KEY,
          @type = @string,
          @default = "spectrum_waving.tna"
        },

        fourier_coefficients =
        { @key = IMPROVED_REAL_IMAG_KEY,
          @type = @boolean,
          @default = false
        },

        improved_re_im_file =
        { @key = IMPROVED_RE_IM_FILE_KEY,
          @type = @string,
          @default = "fourier_coefficients"
        },

        neighborhood_width =
        { @key = NEIGHBORHOOD_WIDTH_KEY,
          @tooltip = "this must be an odd number, minimum 3",
          @type = @integer,
          @default = 3,
          @min = 3
        },

        frequency_weighting =
        { @key = FREQUENCY_WEIGHTING_KEY,
          @optional = yes,
          @type = @array,
          @depth = 1,
          @element = {@type = @real, @default = 1.0}
        }
      }
    }, #frequency_analysis


# -----------------------------------------------
# --- Singular Values Analysis ------------------
# -----------------------------------------------


    singular_value_analysis =
    { @key = SVD_ANALYSIS_KEY,
      @optional = yes,
      @type = @record,
      @record =
      { is_active =
        { @key = IS_ACTIVE_KEY,
	  @label = "is active",	
	  @tooltip = "Activate the method",  
          @type = @boolean,
          @default = false
        },

        points_step =
        { @key = POINTS_STEP_KEY,
          @type = @integer,
          @default = 1,
          @min = 1
        },

        using_last_points =
        { @key = USING_LAST_POINTS_KEY,
          @type = @integer,
          @default = 1000,
          @min = 1
        },

        eigenvalues =
        { @key = EVAL_KEY,
          @type = @boolean,
          @default = true
        },

        eval_file =
        { @key = EVAL_FILE_KEY,
          @type = @string,
          @default = "svd_eval.tna"
        },

        eigenvectors =
        { @key = EVEC_KEY,
          @type = @boolean,
          @default = false
        },

        evec_file =
        { @key = EVEC_FILE_KEY,
          @type = @string,
          @default = "svd_evec.tna"
        },

        covariance_matrix =
        { @key = COV_MATRIX_KEY,
          @type = @boolean,
          @default = false
        },

        cov_matrix_file =
        { @key = COV_MATRIX_FILE_KEY,
          @type = @string,
          @default = "svd_covariance_matrix.tna"
        }
      }
    }, # singular_value_analysis



# -----------------------------------------------
# --- Check for several conditions --------------
# -----------------------------------------------


    check_for_conditions =
    { @key = CONDITIONS_CHECKER_KEY,
      @optional = yes,
      @type = @record,
      @record =
      { is_active =
        { @key = IS_ACTIVE_KEY,
	  @label = "is active",	
	  @tooltip = "Activate the method",  
          @type = @boolean,
          @default = false
        },

        compare_precision =
        { @key = COMPARE_PRECISION_KEY,
          @type = @real,
          @default = 1.0e-10
        },

        number_of_conditions =
        { @key = CONDITIONS_NUMBER_KEY,
          @type = @integer,
          @default = 0,
          @min = 0,
          @readonly = yes
        },

        condition[] =
        { @key = CONDITION,
          @type = @record,
          @dynamic = yes,
          @record =
          { type =
            { @key = CONDITION_TYPE_KEY,
              @type = @enum,
              @enum =
              { any_fixed_point          = ANY_FIXED_POINT_KEY,
                given_points             = GIVEN_POINTS_KEY,
                leaves_rectangle_area    = LEAVES_RECTANGLE_AREA_KEY,
                leaves_circle_area       = LEAVES_CIRCLE_AREA_KEY,
                stays_in_rectangle_area  = STAYS_IN_RECTANGLE_AREA_KEY,
                stays_in_circle_area     = STAYS_IN_CIRCLE_AREA_KEY,
                user_defined             = USER_DEFINED_KEY
              },
              @default = leaves_rectangle_area
            },

            time =
            { @key = SAVE_TIME_KEY,
              @type = @boolean,
              @default = yes
            },

            time_until_fixed_point_file =
            { @key = TIME_UNTIL_FIXED_POINT_FILE_KEY,
              @type = @string,
              @default = "time_until_fixed_point.tna"
            },

            time_until_given_point_file =
            { @key = TIME_UNTIL_GIVEN_POINT_FILE_KEY,
              @type = @string,
              @default = "time_until_point"
            },

            time_until_rectangle_is_leaved_file =
            { @key = TIME_UNTIL_RECTANGLE_IS_LEAVED_FILE_KEY,
              @type = @string,
              @default = "time_until_rectangle_area_is_leaved.tna"
            },

            time_until_circle_is_leaved_file =
            { @key = TIME_UNTIL_CIRCLE_IS_LEAVED_FILE_KEY,
              @type = @string,
              @default = "time_until_circle_area_is_leaved.tna"
            },

            time_until_user_defined_condition_file =
            { @key = TIME_UNTIL_USER_DEFINED_CONDITION_FILE_KEY,
              @type = @string,
              @default = "time_until_user_defined_condition.tna"
            },

            way =
            { @key = SAVE_WAY_KEY,
              @type = @boolean,
              @default = no
            },

            way_until_fixed_point_file =
            { @key = WAY_UNTIL_FIXED_POINT_FILE_KEY,
              @type = @string,
              @default = "way_until_fixed_point.tna"
            },

            way_until_given_point_file =
            { @key = WAY_UNTIL_GIVEN_POINT_FILE_KEY,
              @type = @string,
              @default = "way_until_point"
            },

            way_until_rectangle_is_leaved_file =
            { @key = WAY_UNTIL_RECTANGLE_IS_LEAVED_FILE_KEY,
              @type = @string,
              @default = "way_until_rectangle_area_is_leaved.tna"
            },

            way_until_circle_is_leaved_file =
            { @key = WAY_UNTIL_CIRCLE_IS_LEAVED_FILE_KEY,
              @type = @string,
              @default = "way_until_circle_area_is_leaved.tna"
            },

            way_within_rectangle_file =
            { @key = WAY_WITHIN_RECTANGLE_FILE_KEY,
              @type = @string,
              @default = "way_within_rectangle_area.tna"
            },

            way_within_circle_file =
            { @key = WAY_WITHIN_CIRCLE_FILE_KEY,
              @type = @string,
              @default = "way_within_circle_area.tna"
            },

            way_until_user_defined_condition_file =
            { @key = WAY_UNTIL_USER_DEFINED_CONDITION_FILE_KEY,
              @type = @string,
              @default = "way_until_user_defined_condition.tna"
            },

            setting =
            { @key = SAVE_SETTING_KEY,
              @type = @boolean,
              @default = no
            },

            settings_leading_to_fixed_point_file =
            { @key = SETTINGS_LEADING_TO_FIXED_POINT_FILE_KEY,
              @type = @string,
              @default = "settings_leading_to_fixed_point.tna"
            },

            settings_leading_to_given_point_file =
            { @key = SETTINGS_LEADING_TO_GIVEN_POINT_FILE_KEY,
              @type = @string,
              @default = "settings_leading_to_point"
            },

            settings_leading_from_rectangle_file =
            { @key = SETTINGS_LEADING_FROM_RECTANGLE_FILE_KEY,
              @type = @string,
              @default = "settings_leading_from_rectangle_area.tna"
            },

            settings_leading_from_circle_file =
            { @key = SETTINGS_LEADING_FROM_CIRCLE_FILE_KEY,
              @type = @string,
              @default = "settings_leading_from_circle_area.tna"
            },

            settings_staying_in_rectangle_file =
            { @key = SETTINGS_STAYING_IN_RECTANGLE_FILE_KEY,
              @type = @string,
              @default = "settings_staying_in_rectangle_area.tna"
            },

            settings_staying_in_circle_file =
            { @key = SETTINGS_STAYING_IN_CIRCLE_FILE_KEY,
              @type = @string,
              @default = "settings_staying_in_circle_area.tna"
            },

           settings_for_user_defined_condition_file =
            { @key = SETTINGS_FOR_USER_DEFINED_CONDITION_FILE_KEY,
              @type = @string,
              @default = "settings_for_user_defined_condition.tna"
            },

            ranges =
            { @key = RANGES_KEY,
              @type = @array,
              @depth = 2,
              @element = {@type = @real}
            },

            points =
            { @key = POINTS_KEY,
              @type = @array,
              @depth = 2,
              @element = {@type = @real},
              @dynamic = yes
            },

            center =
            { @key = CENTER_KEY,
              @type = @array,
              @depth = 1,
              @element = {@type = @real}
            },

            radius =
            { @key = RADIUS_KEY,
              @type = @real
            },

            name = 
            { @key = NAME_KEY,
              @type = @string,
              @default = "none",
              @label = "condition name",
   @tooltip = "The name used in the your .cpp file for registering of the user defined condition function"
            }
          }
        }# condition[]
      }

    } #check_for_conditions

  }
}, #InvestigationMethods


# -----------------------------------------------
# --- Visualization -----------------------------
# -----------------------------------------------
visualization = {
 @key = VISUALIZATION_KEY,
 @optional = yes,
 @type = @record,
 @record = {
  is_active = {
   @key = IS_ACTIVE_KEY,
   @label = "is active",	
   @tooltip = "Activate the method",  
   @type = @boolean,
   @default = true
  },

  transient = {
   @key = TRANSIENT_KEY,
   @type = @integer,
   @default = 0,
   @min = 0
  },

  points_step = {
   @key = POINTS_STEP_KEY,
   @type = @integer,
   @default = 1,
   @min = 1
  },

  update_step = {
   @key = UPDATE_STEP_KEY,
   @type = @integer,
   @default = 1,
   @min = 1
  },

  buffer_size = {
   @label = "last states to display",
   @key = BUFFER_SIZE_KEY,
   @type = @integer,
   @default = 1000,
   @min = 3
  },

# --- visualization window --------------------------------

  number_of_windows = {
   @key = WINDOWS_NUMBER_KEY,
   @type = @integer,
   @default = 0,
   @min = 0,
   @readonly = yes
  },

  window[] = {
   @key = WINDOW,
   @type = @record,
   @dynamic = yes,
   @record = {
    type = {
     @key = WINDOW_TYPE_KEY,
     @type = @enum,
     @enum = {
      win1d = WIN1D_KEY,
      win2d = WIN2D_KEY,
      win3d = WIN3D_KEY
     },
     @default = win3d
    },

    title = {
     @key = TITLE_KEY,
     @type = @string,
     @default = "Unnamed Window"
    },

# x- and y-position of the window:
    screen_anchor = {
     @key = SCREEN_ANCHOR_KEY,
     @type = @array,
     @depth = 1,
     @element = {@type = @integer, @min = 0},
     @default = (0, 0)
    },

    width = {
     @key = WIDTH_KEY,
     @type = @integer,
     @default = 200,
     @min = 100
    },

    height = {
     @key = HEIGHT_KEY,
     @type = @integer,
     @default = 200,
     @min = 100
    },

    background_color = {
     @key = BACKGROUND_COLOR_KEY,
     @type = @array,
     @depth = 1,
     @element = {@type = @real, @min = 0.0, @max = 1.0},
     @default = (0.0, 0.0, 0.0)
    },

# --- visualization window object --------------------------------

    number_of_objects = {
     @key = NUMBER_OF_OBJECTS_KEY,
     @type = @integer,
     @default = 0,
     @min = 0,
     @readonly = yes
    },

    object[] = {
     @key = OBJECT,
     @type = @record,
     @dynamic = yes,
     @record = {
      type = {
       @key = OBJECT_TYPE_KEY,
       @type = @enum,
       @enum = {
        curve = CURVE_KEY,
        sphere = SPHERE_KEY,
        marker = MARKER_KEY,
        plane = PLANE_KEY,
        line = LINE_KEY,
        arrow = ARROW_KEY,
        text = TEXT_KEY,
        surface = SURFACE_KEY,
        torus = TORUS_KEY,
        cube = CUBE_KEY,
        scene = SCENE_KEY
       }
      },

      name = {
       @key = NAME_KEY,
       @type = @string
      },

      visible = {
       @key = VISIBLE_KEY,
       @type = @boolean,
       @default = true
      },

      position = { # for all objects
       @key = POSITION_KEY,
       @type = @record,
       @record = {
        offset = { # 3D point, for 2D-windows also (projection)
          @key = OFFSET_KEY,
          @type = @array,
          @depth = 1,
          @element = {@type = @real, @default = 0.0}
        },

        use_variables = {
          @key = USE_VARIABLES_KEY,
          @type = @boolean,
          @default = false
        },

        variables = { # 3D point of buffer indexes
          @label = "indexes to add to offset",
          @key = VARIABLES_KEY,
          @type = @like,
          @like = (visualization,window[],object[],variables)
        },

        time_shift = { # for variables
          @key = TIME_SHIFT_KEY,
          @type = @integer,
          @default = 0
        }
       }
      },

      vector = { # for plane spanning, texts, arrows and lines
       @key = VECTOR_KEY,
       @type = @array,
       @depth = 1,
       @element = {@type = @real}
      },

      vector2 = { # for plane spanning and texts
       @label = "additional vector",
       @key = VECTOR2_KEY,
       @type = @array,
       @depth = 1,
       @element = {@type = @real}
      },

      radius = { # for sphere, torus, marker
       @key = RADIUS_KEY,
       @type = @real,
       @default = 1.0
      },

      inner_radius = { # for torus
       @key = INNER_RADIUS_KEY,
       @type = @real,
       @default = 0.5
      },

      scale = { # 3D-vector for the scaling of solids
       @key = SCALE_KEY,
       @type = @array,
       @depth = 1,
       @element = {@type = @real},
       @default = (1.0, 1.0, 1.0)
      },

      variables = { # for curve
       @label = "state indexes for the curve",
       @key = VARIABLES_KEY,
       @type = @array,
       @depth = 1,
       @element = {@type = @integer, @min = -1}
      },

      plotting_method = {
       @label = "plotting method",
       @key = PLOTTING_METHOD_KEY,
       @type = @enum,
       @enum = {
        line = PLOTTING_METHOD_LINE_KEY,
        points = PLOTTING_METHOD_POINTS_KEY,
        smooth_points = PLOTTING_METHOD_SMOOTH_POINTS_KEY
       }
      },

      coloring_method = {
       @label = "coloring method",
       @key = COLORING_METHOD_KEY,
       @type = @enum,
       @enum = {
        fixed = COLORING_METHOD_FIXED_KEY,
        velocity = COLORING_METHOD_VELOCITY_KEY,
        acceleration = COLORING_METHOD_ACCELERATION_KEY,
        position = COLORING_METHOD_POSITION_KEY
       }
      },

      color = { # RGB's between 0.0 and 1.0 for solids and planes
       @key = COLOR_KEY,
       @type = @array,
       @depth = 1,
       @element = {@type = @real},
       @default = (1.0, 0.0, 0.0)
      },

      lighting = { # for supposedly all solids
       @key = LIGHTING_KEY,
       @type = @boolean,
       @default = true
      },

      alpha = {
       @label = "plane opacity (alpha)",
       @key = ALPHA_KEY,
       @type = @real,
       @default = 1.0
      },

      text = { # the string to be displayed as text
       @key = TEXT_KEY,
       @type = @string,
       @default = "value[variable] is %g"
      },

      variable = { # write the value of a variable as text
       @label = "text variable",
       @key = VARIABLE_KEY,
       @type = @integer,
       @min = -1
      },

      align = { # for text
       @key = ALIGN_KEY,
       @type = @enum,
       @enum = {
        left = LEFT_KEY,
        right = RIGHT_KEY,
        center = CENTER_KEY
       }
      },

      facing = { # for text fonts
       @label = "text facing",
       @key = FACING_KEY,
       @type = @boolean,
       @default = true
      },

      font = {
       @key = FONT_KEY,
       @optional = yes,
       @type = @record,
       @record = {
        size = {
          @key = SIZE_KEY,
          @type = @real,
          @default = 5.5
        },

        boldness = {
          @key = BOLDNESS_KEY,
          @type = @real,
          @default = 1.0
        },

        smooth = {
          @key = SMOOTH_KEY,
          @type = @boolean,
          @default = off
        },

        color = { # RGB's between 0.0 and 1.0
         @key = COLOR_KEY,
         @type = @array,
         @depth = 1,
         @element = {@type = @real},
         @default = (1.0, 1.0, 0.0)
        }
       }
      }, # end of font

      number_of_objects = {
       @key = NUMBER_OF_OBJECTS_KEY,
       @type = @like,
       @like = (visualization, window[], number_of_objects)
      },

      object[] = {
       @key = OBJECT,
       @type = @like,
       @like = (visualization, window[], object[])
      }
     }
    }, # end of object

# --- visualization window axis --------------------------------

    axes = {
     @key = AXES_KEY,
     @optional = yes,
     @type = @record,
     @record = {
      visible = {
       @key = VISIBLE_KEY,
       @type = @boolean,
       @default = true
      },

      stepping = { # 2D or 3D vector
       @optional = yes,
       @label = "ticks per axis",
       @key = STEPPING_KEY,
       @type = @array,
       @depth = 1,
       @element = {@type = @integer, @min = 1, @default = 10}
      },

      color = { # RGB's between 0.0 and 1.0 for solids and planes
       @key = COLOR_KEY,
       @type = @array,
       @depth = 1,
       @element = {@type = @real, @min = 0.0, @max = 1.0},
       @default = (0.0, 0.0, 1.0)
      },

      font = {
       @key = FONT_KEY,
       @type = @like,
       @like = (visualization, window[], object[], font)
      },

      x_label = {
       @label = "x-label",
       @key = X_LABEL_KEY,
       @type = @string,
       @default = "x"
      },

      y_label = {
       @label = "y-label",
       @key = Y_LABEL_KEY,
       @type = @string,
       @default = "y"
      },

      z_label = {
       @label = "z-label",
       @key = Z_LABEL_KEY,
       @type = @string,
       @default = "z"
      }
     }
    }, # axes

# --- visualization window mesh --------------------------------

    mesh = {
     @key = MESH_KEY,
     @type = @like,
     @like = (visualization, window[], axes)
    }, # mesh

# --- visualization window infoscene --------------------------------

    fixed_scene = {
     @label = "info scene",
     @optional = yes,
     @key = FIXED_SCENE_KEY,
     @type = @like,
     @like = (visualization, window[], object[])
    } # ende fixed_scene

# --- visualization window fly --------------------------------

   }
  } # window[]
 }
} # visualization
;
